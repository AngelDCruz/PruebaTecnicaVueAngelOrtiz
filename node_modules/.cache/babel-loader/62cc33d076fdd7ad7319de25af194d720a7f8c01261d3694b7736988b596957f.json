{"ast":null,"code":"import { TweenMax } from 'gsap';\nexport class Winwheel {\n  constructor(options, drawWheel) {\n    var defaultOptions = {\n      canvasId: 'canvas',\n      // Id of the canvas which the wheel is to draw on to.\n      centerX: null,\n      // X position of the center of the wheel. The default of these are null which means will be placed in center of the canvas.\n      centerY: null,\n      // Y position of the wheel center. If left null at time of construct the center of the canvas is used.\n      outerRadius: null,\n      // The radius of the outside of the wheel. If left null it will be set to the radius from the center of the canvas to its shortest side.\n      innerRadius: 0,\n      // Normally 0. Allows the creation of rings / doughnuts if set to value > 0. Should not exceed outer radius.\n      numSegments: 1,\n      // The number of segments. Need at least one to draw.\n      drawMode: 'code',\n      // The draw mode. Possible values are 'code', 'image', 'segmentImage'. Default is code which means segments are drawn using canvas arc() function.\n      rotationAngle: 0,\n      // The angle of rotation of the wheel - 0 is 12 o'clock position.\n      textFontFamily: 'sans-serif',\n      // Segment text font, you should use web safe fonts.\n      textFontSize: 13,\n      // Size of the segment text.\n      textFontWeight: 'bold',\n      // Font weight.\n      textOrientation: 'horizontal',\n      // Either horizontal, vertical, or curved.\n      textAlignment: 'center',\n      // Either center, inner, or outer.\n      textDirection: 'normal',\n      // Either normal or reversed. In normal mode for horizontal text in segment at 3 o'clock is correct way up, in reversed text at 9 o'clock segment is correct way up.\n      textMargin: null,\n      // Margin between the inner or outer of the wheel (depends on textAlignment).\n      textFillStyle: 'black',\n      // This is basically the text colour.\n      textStrokeStyle: null,\n      // Basically the line colour for segment text, only looks good for large text so off by default.\n      textLineWidth: 1,\n      // Width of the lines around the text. Even though this defaults to 1, a line is only drawn if textStrokeStyle specified.\n      fillStyle: 'silver',\n      // The segment background colour.\n      strokeStyle: null,\n      // Segment line colour. Again segment lines only drawn if this is specified.\n      lineWidth: 1,\n      // Width of lines around segments.\n      clearTheCanvas: true,\n      // When set to true the canvas will be cleared before the wheel is drawn.\n      imageOverlay: false,\n      // If set to true in image drawing mode the outline of the segments will be displayed over the image. Does nothing in code drawMode.\n      drawText: true,\n      // By default the text of the segments is rendered in code drawMode and not in image drawMode.\n      pointerAngle: 0,\n      // Location of the pointer that indicates the prize when wheel has stopped. Default is 0 so the (corrected) 12 o'clock position.\n      wheelImage: null,\n      // Must be set to image data in order to use image to draw the wheel - drawMode must also be 'image'.\n      imageDirection: 'N' // Used when drawMode is segmentImage. Default is north, can also be (E)ast, (S)outh, (W)est.\n    };\n\n    // -----------------------------------------\n    // Loop through the default options and create properties of this class set to the value for the option passed in\n    // or if not value for the option was passed in then to the default.\n    for (var key in defaultOptions) {\n      if (options != null && typeof options[key] !== 'undefined') {\n        this[key] = options[key];\n      } else {\n        this[key] = defaultOptions[key];\n      }\n    }\n\n    // Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n    if (options != null) {\n      for (var key in options) {\n        if (typeof this[key] === 'undefined') {\n          this[key] = options[key];\n        }\n      }\n    }\n\n    // ------------------------------------------\n    // If the id of the canvas is set, try to get the canvas as we need it for drawing.\n    if (this.canvasId) {\n      this.canvas = document.getElementById(this.canvasId);\n      if (this.canvas) {\n        // If the centerX and centerY have not been specified in the options then default to center of the canvas\n        // and make the outerRadius half of the canvas width - this means the wheel will fill the canvas.\n        if (this.centerX == null) {\n          this.centerX = this.canvas.width / 2;\n        }\n        if (this.centerY == null) {\n          this.centerY = this.canvas.height / 2;\n        }\n        if (this.outerRadius == null) {\n          // Need to set to half the width of the shortest dimension of the canvas as the canvas may not be square.\n          // Minus the line segment line width otherwise the lines around the segments on the top,left,bottom,right\n          // side are chopped by the edge of the canvas.\n          if (this.canvas.width < this.canvas.height) {\n            this.outerRadius = this.canvas.width / 2 - this.lineWidth;\n          } else {\n            this.outerRadius = this.canvas.height / 2 - this.lineWidth;\n          }\n        }\n\n        // Also get a 2D context to the canvas as we need this to draw with.\n        this.ctx = this.canvas.getContext('2d');\n      } else {\n        this.canvas = null;\n        this.ctx = null;\n      }\n    } else {\n      this.cavnas = null;\n      this.ctx = null;\n    }\n\n    // ------------------------------------------\n    // Add array of segments to the wheel, then populate with segments if number of segments is specified for this object.\n    this.segments = new Array(null);\n    for (var x = 1; x <= this.numSegments; x++) {\n      // If options for the segments have been specified then create a segment sending these options so\n      // the specified values are used instead of the defaults.\n      if (options != null && options['segments'] && typeof options['segments'][x - 1] !== 'undefined') {\n        this.segments[x] = new Segment(options['segments'][x - 1]);\n      } else {\n        this.segments[x] = new Segment();\n      }\n    }\n\n    // ------------------------------------------\n    // Call function to update the segment sizes setting the starting and ending angles.\n    this.updateSegmentSizes();\n\n    // If the text margin is null then set to same as font size as we want some by default.\n    if (this.textMargin === null) {\n      this.textMargin = this.textFontSize / 1.7;\n    }\n\n    // ------------------------------------------\n    // If the animation options have been passed in then create animation object as a property of this class\n    // and pass the options to it so the animation is set. Otherwise create default animation object.\n    if (options != null && options['animation'] && typeof options['animation'] !== 'undefined') {\n      this.animation = new Animation(options['animation']);\n    } else {\n      this.animation = new Animation();\n    }\n\n    // ------------------------------------------\n    // If some pin options then create create a pin object and then pass them in.\n    if (options != null && options['pins'] && typeof options['pins'] !== 'undefined') {\n      this.pins = new Pin(options['pins']);\n    }\n\n    // ------------------------------------------\n    // On that note, if the drawMode is image change some defaults provided a value has not been specified.\n    if (this.drawMode == 'image' || this.drawMode == 'segmentImage') {\n      // Remove grey fillStyle.\n      if (typeof options['fillStyle'] === 'undefined') {\n        this.fillStyle = null;\n      }\n\n      // Set strokeStyle to red.\n      if (typeof options['strokeStyle'] === 'undefined') {\n        this.strokeStyle = 'red';\n      }\n\n      // Set drawText to false as we will assume any text is part of the image.\n      if (typeof options['drawText'] === 'undefined') {\n        this.drawText = false;\n      }\n\n      // Also set the lineWidth to 1 so that segment overlay will look correct.\n      if (typeof options['lineWidth'] === 'undefined') {\n        this.lineWidth = 1;\n      }\n\n      // Set drawWheel to false as normally the image needs to be loaded first.\n      if (typeof drawWheel === 'undefined') {\n        drawWheel = false;\n      }\n    } else {\n      // When in code drawMode the default is the wheel will draw.\n      if (typeof drawWheel === 'undefined') {\n        drawWheel = true;\n      }\n    }\n\n    // Create pointer guide.\n    if (options != null && options['pointerGuide'] && typeof options['pointerGuide'] !== 'undefined') {\n      this.pointerGuide = new PointerGuide(options['pointerGuide']);\n    } else {\n      this.pointerGuide = new PointerGuide();\n    }\n\n    // Finally if drawWheel is true then call function to render the wheel, segment text, overlay etc.\n    if (drawWheel == true) {\n      this.draw(this.clearTheCanvas);\n    } else if (this.drawMode == 'segmentImage') {\n      // If segment image then loop though all the segments and load the images for them setting a callback\n      // which will call the draw function of the wheel once all the images have been loaded.\n      winwheelToDrawDuringAnimation = this;\n      winhweelAlreadyDrawn = false;\n      for (var y = 1; y <= this.numSegments; y++) {\n        if (this.segments[y].image !== null) {\n          this.segments[y].imgData = new Image();\n          this.segments[y].imgData.onload = winwheelLoadedImage;\n          this.segments[y].imgData.src = this.segments[y].image;\n        }\n      }\n    }\n  }\n\n  // ====================================================================================================================\n  // This function sorts out the segment sizes. Some segments may have set sizes, for the others what is left out of\n  // 360 degrees is shared evenly. What this function actually does is set the start and end angle of the arcs.\n  // ====================================================================================================================\n  updateSegmentSizes() {\n    // If this object actually contains some segments\n    if (this.segments) {\n      // First add up the arc used for the segments where the size has been set.\n      var arcUsed = 0;\n      var numSet = 0;\n\n      // Remember, to make it easy to access segments, the position of the segments in the array starts from 1 (not 0).\n      for (var x = 1; x <= this.numSegments; x++) {\n        if (this.segments[x].size !== null) {\n          arcUsed += this.segments[x].size;\n          numSet++;\n        }\n      }\n      var arcLeft = 360 - arcUsed;\n\n      // Create variable to hold how much each segment with non-set size will get in terms of degrees.\n      var degreesEach = 0;\n      if (arcLeft > 0) {\n        degreesEach = arcLeft / (this.numSegments - numSet);\n      }\n\n      // ------------------------------------------\n      // Now loop though and set the start and end angle of each segment.\n      var currentDegree = 0;\n      for (var x = 1; x <= this.numSegments; x++) {\n        // Set start angle.\n        this.segments[x].startAngle = currentDegree;\n\n        // If the size is set then add this to the current degree to get the end, else add the degreesEach to it.\n        if (this.segments[x].size) {\n          currentDegree += this.segments[x].size;\n        } else {\n          currentDegree += degreesEach;\n        }\n\n        // Set end angle.\n        this.segments[x].endAngle = currentDegree;\n      }\n    }\n  }\n\n  // ====================================================================================================================\n  // This function clears the canvas. Will wipe anything else which happens to be drawn on it.\n  // ====================================================================================================================\n  clearCanvas() {\n    if (this.ctx) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  // ====================================================================================================================\n  // This function draws / re-draws the wheel on the canvas therefore rendering any changes.\n  // ====================================================================================================================\n  draw(clearTheCanvas) {\n    // If have the canvas context.\n    if (this.ctx) {\n      // Clear the canvas, unless told not to.\n      if (typeof clearTheCanvas !== 'undefined') {\n        if (clearTheCanvas == true) {\n          this.clearCanvas();\n        }\n      } else {\n        this.clearCanvas();\n      }\n\n      // Call functions to draw the segments and then segment text.\n      if (this.drawMode == 'image') {\n        // Draw the wheel by loading and drawing an image such as a png on the canvas.\n        this.drawWheelImage();\n\n        // If we are to draw the text, do so before the overlay is drawn\n        // as this allows the overlay to be used to create some interesting effects.\n        if (this.drawText == true) {\n          this.drawSegmentText();\n        }\n\n        // If image overlay is true then call function to draw the segments over the top of the image.\n        // This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\n        if (this.imageOverlay == true) {\n          this.drawSegments();\n        }\n      } else if (this.drawMode == 'segmentImage') {\n        // Draw the wheel by rendering the image for each segment.\n        this.drawSegmentImages();\n\n        // If we are to draw the text, do so before the overlay is drawn\n        // as this allows the overlay to be used to create some interesting effects.\n        if (this.drawText == true) {\n          this.drawSegmentText();\n        }\n\n        // If image overlay is true then call function to draw the segments over the top of the image.\n        // This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\n        if (this.imageOverlay == true) {\n          this.drawSegments();\n        }\n      } else {\n        // The default operation is to draw the segments using code via the canvas arc() method.\n        this.drawSegments();\n\n        // The text is drawn on top.\n        if (this.drawText == true) {\n          this.drawSegmentText();\n        }\n      }\n\n      // If this class has pins.\n      if (typeof this.pins !== 'undefined') {\n        // If they are to be visible then draw them.\n        if (this.pins.visible == true) this.drawPins();\n      }\n\n      // If pointer guide is display property is set to true then call function to draw the pointer guide.\n      if (this.pointerGuide.display == true) {\n        this.drawPointerGuide();\n      }\n    }\n  }\n\n  // ====================================================================================================================\n  // Draws the pins around the outside of the wheel.\n  // ====================================================================================================================\n  drawPins() {\n    if (this.pins && this.pins.number) {\n      // Work out the angle to draw each pin a which is simply 360 / the number of pins as they space evenly around.\n      //++ There is a slight oddity with the pins in that there is a pin at 0 and also one at 360 and these will be drawn\n      //++ directly over the top of each other. Also pins are 0 indexed which could possibly cause some confusion\n      //++ with the getCurrentPin function - for now this is just used for audio so probably not a problem.\n      var pinSpacing = 360 / this.pins.number;\n      for (var i = 1; i <= this.pins.number; i++) {\n        this.ctx.save();\n\n        // Set the stroke style and line width.\n        this.ctx.strokeStyle = this.pins.strokeStyle;\n        this.ctx.lineWidth = this.pins.lineWidth;\n        this.ctx.fillStyle = this.pins.fillStyle;\n\n        // Move to the center.\n        this.ctx.translate(this.centerX, this.centerY);\n\n        // Rotate to to the pin location which is i * the pinSpacing.\n        this.ctx.rotate(this.degToRad(i * pinSpacing + this.rotationAngle));\n\n        // Move back out.\n        this.ctx.translate(-this.centerX, -this.centerY);\n\n        // Create a path for the pin circle.\n        this.ctx.beginPath();\n        // x, y, radius, startAngle, endAngle.\n        this.ctx.arc(this.centerX, this.centerY - this.outerRadius + this.pins.outerRadius + this.pins.margin, this.pins.outerRadius, 0, 2 * Math.PI);\n        if (this.pins.fillStyle) this.ctx.fill();\n        if (this.pins.strokeStyle) this.ctx.stroke();\n        this.ctx.restore();\n      }\n    }\n  }\n\n  // ====================================================================================================================\n  // Draws a line from the center of the wheel to the outside at the angle where the code thinks the pointer is.\n  // ====================================================================================================================\n  drawPointerGuide() {\n    // If have canvas context.\n    if (this.ctx) {\n      this.ctx.save();\n\n      // Rotate the canvas to the line goes towards the location of the pointer.\n      this.ctx.translate(this.centerX, this.centerY);\n      this.ctx.rotate(this.degToRad(this.pointerAngle));\n      this.ctx.translate(-this.centerX, -this.centerY);\n\n      // Set line colour and width.\n      this.ctx.strokeStyle = this.pointerGuide.strokeStyle;\n      this.ctx.lineWidth = this.pointerGuide.lineWidth;\n\n      // Draw from the center of the wheel outwards past the wheel outer radius.\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.centerX, this.centerY);\n      this.ctx.lineTo(this.centerX, -(this.outerRadius / 4));\n      this.ctx.stroke();\n      this.ctx.restore();\n    }\n  }\n\n  // ====================================================================================================================\n  // This function takes an image such as PNG and draws it on the canvas making its center at the centerX and center for the wheel.\n  // ====================================================================================================================\n  drawWheelImage() {\n    // Double check the wheelImage property of this class is not null. This does not actually detect that an image\n    // source was set and actually loaded so might get error if this is not the case. This is why the initial call\n    // to draw() should be done from a wheelImage.onload callback as detailed in example documentation.\n    if (this.wheelImage != null) {\n      // Work out the correct X and Y to draw the image at. We need to get the center point of the image\n      // aligned over the center point of the wheel, we can't just place it at 0, 0.\n      var imageLeft = this.centerX - this.wheelImage.height / 2;\n      var imageTop = this.centerY - this.wheelImage.width / 2;\n\n      // Rotate and then draw the wheel.\n      // We must rotate by the rotationAngle before drawing to ensure that image wheels will spin.\n      this.ctx.save();\n      this.ctx.translate(this.centerX, this.centerY);\n      this.ctx.rotate(this.degToRad(this.rotationAngle));\n      this.ctx.translate(-this.centerX, -this.centerY);\n      this.ctx.drawImage(this.wheelImage, imageLeft, imageTop);\n      this.ctx.restore();\n    }\n  }\n\n  // ====================================================================================================================\n  // This function draws the wheel on the canvas by rendering the image for each segment.\n  // ====================================================================================================================\n  drawSegmentImages() {\n    // Again check have context in case this function was called directly and not via draw function.\n    if (this.ctx) {\n      // Draw the segments if there is at least one in the segments array.\n      if (this.segments) {\n        // Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\n        // this is to avoid confusion when talking about the first segment.\n        for (var x = 1; x <= this.numSegments; x++) {\n          // Get the segment object as we need it to read options from.\n          var seg = this.segments[x];\n\n          // Check image has loaded so a property such as height has a value.\n          if (seg.imgData.height) {\n            // Work out the correct X and Y to draw the image at which depends on the direction of the image.\n            // Images can be created in 4 directions. North, South, East, West.\n            // North: Outside at top, inside at bottom. Sits evenly over the 0 degrees angle.\n            // South: Outside at bottom, inside at top. Sits evenly over the 180 degrees angle.\n            // East: Outside at right, inside at left. Sits evenly over the 90 degrees angle.\n            // West: Outside at left, inside at right. Sits evenly over the 270 degrees angle.\n            var imageLeft = 0;\n            var imageTop = 0;\n            var imageAngle = 0;\n            var imageDirection = '';\n            if (seg.imageDirection !== null) imageDirection = seg.imageDirection;else imageDirection = this.imageDirection;\n            if (imageDirection == 'S') {\n              // Left set so image sits half/half over the 180 degrees point.\n              imageLeft = this.centerX - seg.imgData.width / 2;\n\n              // Top so image starts at the centerY.\n              imageTop = this.centerY;\n\n              // Angle to draw the image is its starting angle + half its size.\n              // Here we add 180 to the angle to the segment is poistioned correctly.\n              imageAngle = seg.startAngle + 180 + (seg.endAngle - seg.startAngle) / 2;\n            } else if (imageDirection == 'E') {\n              // Left set so image starts and the center point.\n              imageLeft = this.centerX;\n\n              // Top is so that it sits half/half over the 90 degree point.\n              imageTop = this.centerY - seg.imgData.height / 2;\n\n              // Again get the angle in the center of the segment and add it to the rotation angle.\n              // this time we need to add 270 to that to the segment is rendered the correct place.\n              imageAngle = seg.startAngle + 270 + (seg.endAngle - seg.startAngle) / 2;\n            } else if (imageDirection == 'W') {\n              // Left is the centerX minus the width of the image.\n              imageLeft = this.centerX - seg.imgData.width;\n\n              // Top is so that it sits half/half over the 270 degree point.\n              imageTop = this.centerY - seg.imgData.height / 2;\n\n              // Again get the angle in the center of the segment and add it to the rotation angle.\n              // this time we need to add 90 to that to the segment is rendered the correct place.\n              imageAngle = seg.startAngle + 90 + (seg.endAngle - seg.startAngle) / 2;\n            } // North is the default.\n            else {\n              // Left set so image sits half/half over the 0 degrees point.\n              imageLeft = this.centerX - seg.imgData.width / 2;\n\n              // Top so image is its height out (above) the center point.\n              imageTop = this.centerY - seg.imgData.height;\n\n              // Angle to draw the image is its starting angle + half its size.\n              // this sits it half/half over the center angle of the segment.\n              imageAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2;\n            }\n\n            // --------------------------------------------------\n            // Rotate to the position of the segment and then draw the image.\n            this.ctx.save();\n            this.ctx.translate(this.centerX, this.centerY);\n\n            // So math here is the rotation angle of the wheel plus half way between the start and end angle of the segment.\n            this.ctx.rotate(this.degToRad(this.rotationAngle + imageAngle));\n            this.ctx.translate(-this.centerX, -this.centerY);\n\n            // Draw the image.\n            this.ctx.drawImage(seg.imgData, imageLeft, imageTop);\n            this.ctx.restore();\n          } else {\n            console.log('Segment ' + x + ' imgData is not loaded');\n          }\n        }\n      }\n    }\n  }\n\n  // ====================================================================================================================\n  // This function draws the wheel on the page by rendering the segments on the canvas.\n  // ====================================================================================================================\n  drawSegments() {\n    // Again check have context in case this function was called directly and not via draw function.\n    if (this.ctx) {\n      // Draw the segments if there is at least one in the segments array.\n      if (this.segments) {\n        // Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\n        // this is to avoid confusion when talking about the first segment.\n        for (var x = 1; x <= this.numSegments; x++) {\n          // Get the segment object as we need it to read options from.\n          var seg = this.segments[x];\n          var fillStyle;\n          var lineWidth;\n          var strokeStyle;\n\n          // Set the variables that defined in the segment, or use the default options.\n          if (seg.fillStyle !== null) fillStyle = seg.fillStyle;else fillStyle = this.fillStyle;\n          this.ctx.fillStyle = fillStyle;\n          if (seg.lineWidth !== null) lineWidth = seg.lineWidth;else lineWidth = this.lineWidth;\n          this.ctx.lineWidth = lineWidth;\n          if (seg.strokeStyle !== null) strokeStyle = seg.strokeStyle;else strokeStyle = this.strokeStyle;\n          this.ctx.strokeStyle = strokeStyle;\n\n          // Check there is a strokeStyle or fillStyle, if either the the segment is invisible so should not\n          // try to draw it otherwise a path is began but not ended.\n          if (strokeStyle || fillStyle) {\n            // ----------------------------------\n            // Begin a path as the segment consists of an arc and 2 lines.\n            this.ctx.beginPath();\n\n            // If don't have an inner radius then move to the center of the wheel as we want a line out from the center\n            // to the start of the arc for the outside of the wheel when we arc. Canvas will draw the connecting line for us.\n            if (!this.innerRadius) {\n              this.ctx.moveTo(this.centerX, this.centerY);\n            } else {\n              //++ do need to draw the starting line in the correct x + y based on the start angle\n              //++ otherwise as seen when the wheel does not use up 360 the starting segment is missing the stroked side,\n            }\n\n            // Draw the outer arc of the segment clockwise in direction -->\n            this.ctx.arc(this.centerX, this.centerY, this.outerRadius, this.degToRad(seg.startAngle + this.rotationAngle - 90), this.degToRad(seg.endAngle + this.rotationAngle - 90), false);\n            if (this.innerRadius) {\n              // Draw another arc, this time anticlockwise <-- at the innerRadius between the end angle and the start angle.\n              // Canvas will draw a connecting line from the end of the outer arc to the beginning of the inner arc completing the shape.\n\n              //++ Think the reason the lines are thinner for 2 of the segments is because the thing auto chops part of it\n              //++ when doing the next one. Again think that actually drawing the lines will help.\n\n              this.ctx.arc(this.centerX, this.centerY, this.innerRadius, this.degToRad(seg.endAngle + this.rotationAngle - 90), this.degToRad(seg.startAngle + this.rotationAngle - 90), true);\n            } else {\n              // If no inner radius then we draw a line back to the center of the wheel.\n              this.ctx.lineTo(this.centerX, this.centerY);\n            }\n\n            // Fill and stroke the segment. Only do either if a style was specified, if the style is null then\n            // we assume the developer did not want that particular thing.\n            // For example no stroke style so no lines to be drawn.\n            if (fillStyle) this.ctx.fill();\n            if (strokeStyle) this.ctx.stroke();\n          }\n        }\n      }\n    }\n  }\n\n  // ====================================================================================================================\n  // This draws the text on the segments using the specified text options.\n  // ====================================================================================================================\n  drawSegmentText() {\n    // Again only draw the text if have a canvas context.\n    if (this.ctx) {\n      // Declare variables to hold the values. These are populated either with the value for the specific segment,\n      // or if not specified then the global default value.\n      var fontFamily;\n      var fontSize;\n      var fontWeight;\n      var orientation;\n      var alignment;\n      var direction;\n      var margin;\n      var fillStyle;\n      var strokeStyle;\n      var lineWidth;\n      var fontSetting;\n\n      // Loop though all the segments.\n      for (var x = 1; x <= this.numSegments; x++) {\n        // Save the context so it is certain that each segment text option will not affect the other.\n        this.ctx.save();\n\n        // Get the segment object as we need it to read options from.\n        var seg = this.segments[x];\n\n        // Check is text as no point trying to draw if there is no text to render.\n        if (seg.text) {\n          // Set values to those for the specific segment or use global default if null.\n          if (seg.textFontFamily !== null) fontFamily = seg.textFontFamily;else fontFamily = this.textFontFamily;\n          if (seg.textFontSize !== null) fontSize = seg.textFontSize;else fontSize = this.textFontSize;\n          if (seg.textFontWeight !== null) fontWeight = seg.textFontWeight;else fontWeight = this.textFontWeight;\n          if (seg.textOrientation !== null) orientation = seg.textOrientation;else orientation = this.textOrientation;\n          if (seg.textAlignment !== null) alignment = seg.textAlignment;else alignment = this.textAlignment;\n          if (seg.textDirection !== null) direction = seg.textDirection;else direction = this.textDirection;\n          if (seg.textMargin !== null) margin = seg.textMargin;else margin = this.textMargin;\n          if (seg.textFillStyle !== null) fillStyle = seg.textFillStyle;else fillStyle = this.textFillStyle;\n          if (seg.textStrokeStyle !== null) strokeStyle = seg.textStrokeStyle;else strokeStyle = this.textStrokeStyle;\n          if (seg.textLineWidth !== null) lineWidth = seg.textLineWidth;else lineWidth = this.textLineWidth;\n\n          // ------------------------------\n          // We need to put the font bits together in to one string.\n          fontSetting = '';\n          if (fontWeight != null) fontSetting += fontWeight + ' ';\n          if (fontSize != null) fontSetting += fontSize + 'px '; // Fonts on canvas are always a px value.\n\n          if (fontFamily != null) fontSetting += fontFamily;\n\n          // Now set the canvas context to the decided values.\n          this.ctx.font = fontSetting;\n          this.ctx.fillStyle = fillStyle;\n          this.ctx.strokeStyle = strokeStyle;\n          this.ctx.lineWidth = lineWidth;\n\n          // Split the text in to multiple lines on the \\n character.\n          var lines = seg.text.split('\\n');\n\n          // Figure out the starting offset for the lines as when there are multiple lines need to center the text\n          // vertically in the segment (when thinking of normal horozontal text).\n          var lineOffset = 0 - fontSize * (lines.length / 2) + fontSize / 2;\n\n          // The offset works great for horozontal and vertial text, also centered curved. But when the text is curved\n          // and the alignment is outer then the multiline text should not have some text outside the wheel. Same if inner curved.\n          if (orientation == 'curved' && (alignment == 'inner' || alignment == 'outer')) {\n            lineOffset = 0;\n          }\n          for (var i = 0; i < lines.length; i++) {\n            // ---------------------------------\n            // If direction is reversed then do things differently than if normal (which is the default - see further down)\n            if (direction == 'reversed') {\n              // When drawing reversed or 'upside down' we need to do some trickery on our part.\n              // The canvas text rendering function still draws the text left to right and the correct way up,\n              // so we need to overcome this with rotating the opposite side of the wheel the correct way up then pulling the text\n              // through the center point to the correct segment it is supposed to be on.\n              if (orientation == 'horizontal') {\n                if (alignment == 'inner') this.ctx.textAlign = 'right';else if (alignment == 'outer') this.ctx.textAlign = 'left';else this.ctx.textAlign = 'center';\n                this.ctx.textBaseline = 'middle';\n\n                // Work out the angle to rotate the wheel, this is in the center of the segment but on the opposite side of the wheel which is why do -180.\n                var textAngle = this.degToRad(seg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90 - 180);\n                this.ctx.save();\n                this.ctx.translate(this.centerX, this.centerY);\n                this.ctx.rotate(textAngle);\n                this.ctx.translate(-this.centerX, -this.centerY);\n                if (alignment == 'inner') {\n                  // In reversed state the margin is subtracted from the innerX.\n                  // When inner the inner radius also comes in to play.\n                  if (fillStyle) this.ctx.fillText(lines[i], this.centerX - this.innerRadius - margin, this.centerY + lineOffset);\n                  if (strokeStyle) this.ctx.strokeText(lines[i], this.centerX - this.innerRadius - margin, this.centerY + lineOffset);\n                } else if (alignment == 'outer') {\n                  // In reversed state the position is the center minus the radius + the margin for outer aligned text.\n                  if (fillStyle) this.ctx.fillText(lines[i], this.centerX - this.outerRadius + margin, this.centerY + lineOffset);\n                  if (strokeStyle) this.ctx.strokeText(lines[i], this.centerX - this.outerRadius + margin, this.centerY + lineOffset);\n                } else {\n                  // In reversed state the everything in minused.\n                  if (fillStyle) this.ctx.fillText(lines[i], this.centerX - this.innerRadius - (this.outerRadius - this.innerRadius) / 2 - margin, this.centerY + lineOffset);\n                  if (strokeStyle) this.ctx.strokeText(lines[i], this.centerX - this.innerRadius - (this.outerRadius - this.innerRadius) / 2 - margin, this.centerY + lineOffset);\n                }\n                this.ctx.restore();\n              } else if (orientation == 'vertical') {\n                // See normal code further down for comments on how it works, this is similar by plus/minus is reversed.\n                this.ctx.textAlign = 'center';\n\n                // In reversed mode this are reversed.\n                if (alignment == 'inner') this.ctx.textBaseline = 'top';else if (alignment == 'outer') this.ctx.textBaseline = 'bottom';else this.ctx.textBaseline = 'middle';\n                var textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2 - 180;\n                textAngle += this.rotationAngle;\n                this.ctx.save();\n                this.ctx.translate(this.centerX, this.centerY);\n                this.ctx.rotate(this.degToRad(textAngle));\n                this.ctx.translate(-this.centerX, -this.centerY);\n                if (alignment == 'outer') var yPos = this.centerY + this.outerRadius - margin;else if (alignment == 'inner') var yPos = this.centerY + this.innerRadius + margin;\n\n                // I have found that the text looks best when a fraction of the font size is shaved off.\n                var yInc = fontSize - fontSize / 9;\n\n                // Loop though and output the characters.\n                if (alignment == 'outer') {\n                  // In reversed mode outer means text in 6 o'clock segment sits at bottom of the wheel and we draw up.\n                  for (var c = lines[i].length - 1; c >= 0; c--) {\n                    character = lines[i].charAt(c);\n                    if (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos);\n                    if (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos);\n                    yPos -= yInc;\n                  }\n                } else if (alignment == 'inner') {\n                  // In reversed mode inner text is drawn from top of segment at 6 o'clock position to bottom of the wheel.\n                  for (var c = 0; c < lines[i].length; c++) {\n                    character = lines[i].charAt(c);\n                    if (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos);\n                    if (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos);\n                    yPos += yInc;\n                  }\n                } else if (alignment == 'center') {\n                  // Again for reversed this is the opposite of before.\n                  // If there is more than one character in the text then an adjustment to the position needs to be done.\n                  // What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\n                  var centerAdjustment = 0;\n                  if (lines[i].length > 1) {\n                    centerAdjustment = yInc * (lines[i].length - 1) / 2;\n                  }\n                  var yPos = this.centerY + this.innerRadius + (this.outerRadius - this.innerRadius) / 2 + centerAdjustment + margin;\n                  for (var c = lines[i].length - 1; c >= 0; c--) {\n                    character = lines[i].charAt(c);\n                    if (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos);\n                    if (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos);\n                    yPos -= yInc;\n                  }\n                }\n                this.ctx.restore();\n              } else if (orientation == 'curved') {\n                // There is no built in canvas function to draw text around an arc,\n                // so we need to do this ourselves.\n                var radius = 0;\n\n                // Set the alignment of the text - inner, outer, or center by calculating\n                // how far out from the center point of the wheel the text is drawn.\n                if (alignment == 'inner') {\n                  // When alignment is inner the radius is the innerRadius plus any margin.\n                  radius = this.innerRadius + margin;\n                  this.ctx.textBaseline = 'top';\n                } else if (alignment == 'outer') {\n                  // Outer it is the outerRadius minus any margin.\n                  radius = this.outerRadius - margin;\n                  this.ctx.textBaseline = 'bottom';\n\n                  // We need to adjust the radius in this case to take in to multiline text.\n                  // In this case the radius needs to be further out, not at the inner radius.\n                  radius -= fontSize * (lines.length - 1);\n                } else if (alignment == 'center') {\n                  // When center we want the text halfway between the inner and outer radius.\n                  radius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2;\n                  this.ctx.textBaseline = 'middle';\n                }\n\n                // Set the angle to increment by when looping though and outputting the characters in the text\n                // as we do this by rotating the wheel small amounts adding each character.\n                var anglePerChar = 0;\n                var drawAngle = 0;\n\n                // If more than one character in the text then...\n                if (lines[i].length > 1) {\n                  // Text is drawn from the left.\n                  this.ctx.textAlign = 'left';\n\n                  // Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\n                  // I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\n                  // using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\n                  anglePerChar = 4 * (fontSize / 10);\n\n                  // Work out what percentage the radius the text will be drawn at is of 100px.\n                  radiusPercent = 100 / radius;\n\n                  // Then use this to scale up or down the anglePerChar value.\n                  // When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\n                  // away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\n                  anglePerChar = anglePerChar * radiusPercent;\n\n                  // Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\n                  // To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\n                  // of the segment so that it sits centred.\n                  totalArc = anglePerChar * lines[i].length;\n\n                  // Now set initial draw angle to half way between the start and end of the segment.\n                  drawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2);\n                } else {\n                  // The initial draw angle is the center of the segment when only one character.\n                  drawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2;\n\n                  // To ensure is dead-center the text alignment also needs to be centered.\n                  this.ctx.textAlign = 'center';\n                }\n\n                // ----------------------\n                // Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\n                drawAngle += this.rotationAngle;\n\n                // And as with other 'reverse' text direction functions we need to subtract 180 degrees from the angle\n                // because when it comes to draw the characters in the loop below we add the radius instead of subtract it.\n                drawAngle -= 180;\n\n                // ----------------------\n                // Now the drawing itself.\n                // In reversed direction mode we loop through the characters in the text backwards in order for them to appear on screen correctly\n                for (c = lines[i].length; c >= 0; c--) {\n                  this.ctx.save();\n                  character = lines[i].charAt(c);\n\n                  // Rotate the wheel to the draw angle as we need to add the character at this location.\n                  this.ctx.translate(this.centerX, this.centerY);\n                  this.ctx.rotate(this.degToRad(drawAngle));\n                  this.ctx.translate(-this.centerX, -this.centerY);\n\n                  // Now draw the character directly below the center point of the wheel at the appropriate radius.\n                  // Note in the reversed mode we add the radius to the this.centerY instead of subtract.\n                  if (strokeStyle) this.ctx.strokeText(character, this.centerX, this.centerY + radius + lineOffset);\n                  if (fillStyle) this.ctx.fillText(character, this.centerX, this.centerY + radius + lineOffset);\n\n                  // Increment the drawAngle by the angle per character so next loop we rotate\n                  // to the next angle required to draw the character at.\n                  drawAngle += anglePerChar;\n                  this.ctx.restore();\n                }\n              }\n            } else {\n              // Normal direction so do things normally.\n              // Check text orientation, of horizontal then reasonably straight forward, if vertical then a bit more work to do.\n              if (orientation == 'horizontal') {\n                // Based on the text alignment, set the correct value in the context.\n                if (alignment == 'inner') this.ctx.textAlign = 'left';else if (alignment == 'outer') this.ctx.textAlign = 'right';else this.ctx.textAlign = 'center';\n\n                // Set this too.\n                this.ctx.textBaseline = 'middle';\n\n                // Work out the angle around the wheel to draw the text at, which is simply in the middle of the segment the text is for.\n                // The rotation angle is added in to correct the annoyance with the canvas arc drawing functions which put the 0 degrees at the 3 oclock\n                var textAngle = this.degToRad(seg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90);\n\n                // We need to rotate in order to draw the text because it is output horizontally, so to\n                // place correctly around the wheel for all but a segment at 3 o'clock we need to rotate.\n                this.ctx.save();\n                this.ctx.translate(this.centerX, this.centerY);\n                this.ctx.rotate(textAngle);\n                this.ctx.translate(-this.centerX, -this.centerY);\n\n                // --------------------------\n                // Draw the text based on its alignment adding margin if inner or outer.\n                if (alignment == 'inner') {\n                  // Inner means that the text is aligned with the inner of the wheel. If looking at a segment in in the 3 o'clock position\n                  // it would look like the text is left aligned within the segment.\n\n                  // Because the segments are smaller towards the inner of the wheel, in order for the text to fit is is a good idea that\n                  // a margin is added which pushes the text towards the outer a bit.\n\n                  // The inner radius also needs to be taken in to account as when inner aligned.\n\n                  // If fillstyle is set the draw the text filled in.\n                  if (fillStyle) this.ctx.fillText(lines[i], this.centerX + this.innerRadius + margin, this.centerY + lineOffset);\n\n                  // If stroke style is set draw the text outline.\n                  if (strokeStyle) this.ctx.strokeText(lines[i], this.centerX + this.innerRadius + margin, this.centerY + lineOffset);\n                } else if (alignment == 'outer') {\n                  // Outer means the text is aligned with the outside of the wheel, so if looking at a segment in the 3 o'clock position\n                  // it would appear the text is right aligned. To position we add the radius of the wheel in to the equation\n                  // and subtract the margin this time, rather than add it.\n\n                  // I don't understand why, but in order of the text to render correctly with stroke and fill, the stroke needs to\n                  // come first when drawing outer, rather than second when doing inner.\n                  if (fillStyle) this.ctx.fillText(lines[i], this.centerX + this.outerRadius - margin, this.centerY + lineOffset);\n\n                  // If fillstyle the fill the text.\n                  if (strokeStyle) this.ctx.strokeText(lines[i], this.centerX + this.outerRadius - margin, this.centerY + lineOffset);\n                } else {\n                  // In this case the text is to drawn centred in the segment.\n                  // Typically no margin is required, however even though centred the text can look closer to the inner of the wheel\n                  // due to the way the segments narrow in (is optical effect), so if a margin is specified it is placed on the inner\n                  // side so the text is pushed towards the outer.\n\n                  // If stoke style the stroke the text.\n                  if (fillStyle) this.ctx.fillText(lines[i], this.centerX + this.innerRadius + (this.outerRadius - this.innerRadius) / 2 + margin, this.centerY + lineOffset);\n\n                  // If fillstyle the fill the text.\n                  if (strokeStyle) this.ctx.strokeText(lines[i], this.centerX + this.innerRadius + (this.outerRadius - this.innerRadius) / 2 + margin, this.centerY + lineOffset);\n                }\n\n                // Restore the context so that wheel is returned to original position.\n                this.ctx.restore();\n              } else if (orientation == 'vertical') {\n                // If vertical then we need to do this ourselves because as far as I am aware there is no option built in to html canvas\n                // which causes the text to draw downwards or upwards one character after another.\n\n                // In this case the textAlign is always center, but the baseline is either top or bottom\n                // depending on if inner or outer alignment has been specified.\n                this.ctx.textAlign = 'center';\n                if (alignment == 'inner') this.ctx.textBaseline = 'bottom';else if (alignment == 'outer') this.ctx.textBaseline = 'top';else this.ctx.textBaseline = 'middle';\n\n                // The angle to draw the text at is halfway between the end and the starting angle of the segment.\n                var textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2;\n\n                // Ensure the rotation angle of the wheel is added in, otherwise the test placement won't match\n                // the segments they are supposed to be for.\n                textAngle += this.rotationAngle;\n\n                // Rotate so can begin to place the text.\n                this.ctx.save();\n                this.ctx.translate(this.centerX, this.centerY);\n                this.ctx.rotate(this.degToRad(textAngle));\n                this.ctx.translate(-this.centerX, -this.centerY);\n\n                // Work out the position to start drawing in based on the alignment.\n                // If outer then when considering a segment at the 12 o'clock position want to start drawing down from the top of the wheel.\n                if (alignment == 'outer') var yPos = this.centerY - this.outerRadius + margin;else if (alignment == 'inner') var yPos = this.centerY - this.innerRadius - margin;\n\n                // We need to know how much to move the y axis each time.\n                // This is not quite simply the font size as that puts a larger gap in between the letters\n                // than expected, especially with monospace fonts. I found that shaving a little off makes it look \"right\".\n                var yInc = fontSize - fontSize / 9;\n\n                // Loop though and output the characters.\n                if (alignment == 'outer') {\n                  // For this alignment we draw down from the top of a segment at the 12 o'clock position to simply\n                  // loop though the characters in order.\n                  for (var c = 0; c < lines[i].length; c++) {\n                    character = lines[i].charAt(c);\n                    if (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos);\n                    if (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos);\n                    yPos += yInc;\n                  }\n                } else if (alignment == 'inner') {\n                  // Here we draw from the inner of the wheel up, but in order for the letters in the text text to\n                  // remain in the correct order when reading, we actually need to loop though the text characters backwards.\n                  for (var c = lines[i].length - 1; c >= 0; c--) {\n                    character = lines[i].charAt(c);\n                    if (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos);\n                    if (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos);\n                    yPos -= yInc;\n                  }\n                } else if (alignment == 'center') {\n                  // This is the most complex of the three as we need to draw the text top down centred between the inner and outer of the wheel.\n                  // So logically we have to put the middle character of the text in the center then put the others each side of it.\n                  // In reality that is a really bad way to do it, we can achieve the same if not better positioning using a\n                  // variation on the method used for the rendering of outer aligned text once we have figured out the height of the text.\n\n                  // If there is more than one character in the text then an adjustment to the position needs to be done.\n                  // What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\n                  var centerAdjustment = 0;\n                  if (lines[i].length > 1) {\n                    centerAdjustment = yInc * (lines[i].length - 1) / 2;\n                  }\n\n                  // Now work out where to start rendering the string. This is half way between the inner and outer of the wheel, with the\n                  // centerAdjustment included to correctly position texts with more than one character over the center.\n                  // If there is a margin it is used to push the text away from the center of the wheel.\n                  var yPos = this.centerY - this.innerRadius - (this.outerRadius - this.innerRadius) / 2 - centerAdjustment - margin;\n\n                  // Now loop and draw just like outer text rendering.\n                  for (var c = 0; c < lines[i].length; c++) {\n                    character = lines[i].charAt(c);\n                    if (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos);\n                    if (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos);\n                    yPos += yInc;\n                  }\n                }\n                this.ctx.restore();\n              } else if (orientation == 'curved') {\n                // There is no built in canvas function to draw text around an arc, so\n                // we need to do this ourselves.\n                var radius = 0;\n\n                // Set the alignment of the text - inner, outer, or center by calculating\n                // how far out from the center point of the wheel the text is drawn.\n                if (alignment == 'inner') {\n                  // When alignment is inner the radius is the innerRadius plus any margin.\n                  radius = this.innerRadius + margin;\n                  this.ctx.textBaseline = 'bottom';\n\n                  // We need to adjust the radius in this case to take in to multiline text.\n                  // In this case the radius needs to be further out, not at the inner radius.\n                  radius += fontSize * (lines.length - 1);\n                } else if (alignment == 'outer') {\n                  // Outer it is the outerRadius minus any margin.\n                  radius = this.outerRadius - margin;\n                  this.ctx.textBaseline = 'top';\n                } else if (alignment == 'center') {\n                  // When center we want the text halfway between the inner and outer radius.\n                  radius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2;\n                  this.ctx.textBaseline = 'middle';\n                }\n\n                // Set the angle to increment by when looping though and outputting the characters in the text\n                // as we do this by rotating the wheel small amounts adding each character.\n                var anglePerChar = 0;\n                var drawAngle = 0;\n\n                // If more than one character in the text then...\n                if (lines[i].length > 1) {\n                  // Text is drawn from the left.\n                  this.ctx.textAlign = 'left';\n\n                  // Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\n                  // I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\n                  // using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\n                  anglePerChar = 4 * (fontSize / 10);\n\n                  // Work out what percentage the radius the text will be drawn at is of 100px.\n                  radiusPercent = 100 / radius;\n\n                  // Then use this to scale up or down the anglePerChar value.\n                  // When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\n                  // away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\n                  anglePerChar = anglePerChar * radiusPercent;\n\n                  // Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\n                  // To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\n                  // of the segment so that it sits centred.\n                  totalArc = anglePerChar * lines[i].length;\n\n                  // Now set initial draw angle to half way between the start and end of the segment.\n                  drawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2);\n                } else {\n                  // The initial draw angle is the center of the segment when only one character.\n                  drawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2;\n\n                  // To ensure is dead-center the text alignment also needs to be centred.\n                  this.ctx.textAlign = 'center';\n                }\n\n                // ----------------------\n                // Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\n                drawAngle += this.rotationAngle;\n\n                // ----------------------\n                // Now the drawing itself.\n                // Loop for each character in the text.\n                for (c = 0; c < lines[i].length; c++) {\n                  this.ctx.save();\n                  character = lines[i].charAt(c);\n\n                  // Rotate the wheel to the draw angle as we need to add the character at this location.\n                  this.ctx.translate(this.centerX, this.centerY);\n                  this.ctx.rotate(this.degToRad(drawAngle));\n                  this.ctx.translate(-this.centerX, -this.centerY);\n\n                  // Now draw the character directly above the center point of the wheel at the appropriate radius.\n                  if (strokeStyle) this.ctx.strokeText(character, this.centerX, this.centerY - radius + lineOffset);\n                  if (fillStyle) this.ctx.fillText(character, this.centerX, this.centerY - radius + lineOffset);\n\n                  // Increment the drawAngle by the angle per character so next loop we rotate\n                  // to the next angle required to draw the character at.\n                  drawAngle += anglePerChar;\n                  this.ctx.restore();\n                }\n              }\n            }\n\n            // Increment this ready for the next time.\n            lineOffset += fontSize;\n          }\n        }\n\n        // Restore so all text options are reset ready for the next text.\n        this.ctx.restore();\n      }\n    }\n  }\n\n  // ====================================================================================================================\n  // Converts degrees to radians which is what is used when specifying the angles on HTML5 canvas arcs.\n  // ====================================================================================================================\n  degToRad(d) {\n    return d * 0.0174532925199432957;\n  }\n\n  // ====================================================================================================================\n  // This function sets the center location of the wheel, saves a function call to set x then y.\n  // ====================================================================================================================\n  setCenter(x, y) {\n    this.centerX = x;\n    this.centerY = y;\n  }\n\n  // ====================================================================================================================\n  // This function allows a segment to be added to the wheel. The position of the segment is optional,\n  // if not specified the new segment will be added to the end of the wheel.\n  // ====================================================================================================================\n  addSegment(options, position) {\n    // Create a new segment object passing the options in.\n    newSegment = new Segment(options);\n\n    // Increment the numSegments property of the class since new segment being added.\n    this.numSegments++;\n    var segmentPos;\n\n    // Work out where to place the segment, the default is simply as a new segment at the end of the wheel.\n    if (typeof position !== 'undefined') {\n      // Because we need to insert the segment at this position, not overwrite it, we need to move all segments after this\n      // location along one in the segments array, before finally adding this new segment at the specified location.\n      for (var x = this.numSegments; x > position; x--) {\n        this.segments[x] = this.segments[x - 1];\n      }\n      this.segments[position] = newSegment;\n      segmentPos = position;\n    } else {\n      this.segments[this.numSegments] = newSegment;\n      segmentPos = this.numSegments;\n    }\n\n    // Since a segment has been added the segment sizes need to be re-computed so call function to do this.\n    this.updateSegmentSizes();\n\n    // Return the segment object just created in the wheel (JavaScript will return it by reference), so that\n    // further things can be done with it by the calling code if desired.\n    return this.segments[segmentPos];\n  }\n\n  // ====================================================================================================================\n  // This function must be used if the canvasId is changed as we also need to get the context of the new canvas.\n  // ====================================================================================================================\n  setCanvasId(canvasId) {\n    if (canvasId) {\n      this.canvasId = canvasId;\n      this.canvas = document.getElementById(this.canvasId);\n      if (this.canvas) {\n        this.ctx = this.canvas.getContext('2d');\n      }\n    } else {\n      this.canvasId = null;\n      this.ctx = null;\n      this.canvas = null;\n    }\n  }\n\n  // ====================================================================================================================\n  // This function deletes the specified segment from the wheel by removing it from the segments array.\n  // It then sorts out the other bits such as update of the numSegments.\n  // ====================================================================================================================\n  deleteSegment(position) {\n    // There needs to be at least one segment in order for the wheel to draw, so only allow delete if there\n    // is more than one segment currently left in the wheel.\n\n    //++ check that specifying a position that does not exist - say 10 in a 6 segment wheel does not cause issues.\n    if (this.numSegments > 1) {\n      // If the position of the segment to remove has been specified.\n      if (typeof position !== 'undefined') {\n        // The array is to be shortened so we need to move all segments after the one\n        // to be removed down one so there is no gap.\n        for (var x = position; x < this.numSegments; x++) {\n          this.segments[x] = this.segments[x + 1];\n        }\n      }\n\n      // Unset the last item in the segments array since there is now one less.\n      this.segments[this.numSegments] = undefined;\n\n      // Decrement the number of segments,\n      // then call function to update the segment sizes.\n      this.numSegments--;\n      this.updateSegmentSizes();\n    }\n  }\n\n  // ====================================================================================================================\n  // This function takes the x an the y of a mouse event, such as click or move, and converts the x and the y in to\n  // co-ordinates on the canvas as the raw values are the x and the y from the top and left of the user's browser.\n  // ====================================================================================================================\n  windowToCanvas(x, y) {\n    var bbox = this.canvas.getBoundingClientRect();\n    return {\n      x: Math.floor(x - bbox.left * (this.canvas.width / bbox.width)),\n      y: Math.floor(y - bbox.top * (this.canvas.height / bbox.height))\n    };\n  }\n\n  // ====================================================================================================================\n  // This function returns the segment object located at the specified x and y coordinates on the canvas.\n  // It is used to allow things to be done with a segment clicked by the user, such as highlight, display or change some values, etc.\n  // ====================================================================================================================\n  getSegmentAt(x, y) {\n    var foundSegment = null;\n\n    // Call function to return segment number.\n    var segmentNumber = this.getSegmentNumberAt(x, y);\n\n    // If found one then set found segment to pointer to the segment object.\n    if (segmentNumber !== null) {\n      foundSegment = this.segments[segmentNumber];\n    }\n    return foundSegment;\n  }\n\n  // ====================================================================================================================\n  // Returns the number of the segment clicked instead of the segment object.\n  // ====================================================================================================================\n  getSegmentNumberAt(x, y) {\n    // KNOWN ISSUE: this does not work correct if the canvas is scaled using css, or has padding, border.\n    // @TODO see if can find a solution at some point, check windowToCanvas working as needed, then below.\n\n    // Call function above to convert the raw x and y from the user's browser to canvas coordinates\n    // i.e. top and left is top and left of canvas, not top and left of the user's browser.\n    var loc = this.windowToCanvas(x, y);\n\n    // ------------------------------------------\n    // Now start the process of working out the segment clicked.\n    // First we need to figure out the angle of an imaginary line between the centerX and centerY of the wheel and\n    // the X and Y of the location (for example a mouse click).\n    var topBottom;\n    var leftRight;\n    var adjacentSideLength;\n    var oppositeSideLength;\n    var hypotenuseSideLength;\n\n    // We will use right triangle maths with the TAN function.\n    // The start of the triangle is the wheel center, the adjacent side is along the x axis, and the opposite side is along the y axis.\n\n    // We only ever use positive numbers to work out the triangle and the center of the wheel needs to be considered as 0 for the numbers\n    // in the maths which is why there is the subtractions below. We also remember what quadrant of the wheel the location is in as we\n    // need this information later to add 90, 180, 270 degrees to the angle worked out from the triangle to get the position around a 360 degree wheel.\n    if (loc.x > this.centerX) {\n      adjacentSideLength = loc.x - this.centerX;\n      leftRight = 'R'; // Location is in the right half of the wheel.\n    } else {\n      adjacentSideLength = this.centerX - loc.x;\n      leftRight = 'L'; // Location is in the left half of the wheel.\n    }\n\n    if (loc.y > this.centerY) {\n      oppositeSideLength = loc.y - this.centerY;\n      topBottom = 'B'; // Bottom half of wheel.\n    } else {\n      oppositeSideLength = this.centerY - loc.y;\n      topBottom = 'T'; // Top Half of wheel.\n    }\n\n    // Now divide opposite by adjacent to get tan value.\n    var tanVal = oppositeSideLength / adjacentSideLength;\n\n    // Use the tan function and convert results to degrees since that is what we work with.\n    var result = Math.atan(tanVal) * 180 / Math.PI;\n    var locationAngle = 0;\n\n    // We also need the length of the hypotenuse as later on we need to compare this to the outerRadius of the segment / circle.\n    hypotenuseSideLength = Math.sqrt(oppositeSideLength * oppositeSideLength + adjacentSideLength * adjacentSideLength);\n\n    // ------------------------------------------\n    // Now to make sense around the wheel we need to alter the values based on if the location was in top or bottom half\n    // and also right or left half of the wheel, by adding 90, 180, 270 etc. Also for some the initial locationAngle needs to be inverted.\n    if (topBottom == 'T' && leftRight == 'R') {\n      locationAngle = Math.round(90 - result);\n    } else if (topBottom == 'B' && leftRight == 'R') {\n      locationAngle = Math.round(result + 90);\n    } else if (topBottom == 'B' && leftRight == 'L') {\n      locationAngle = Math.round(90 - result + 180);\n    } else if (topBottom == 'T' && leftRight == 'L') {\n      locationAngle = Math.round(result + 270);\n    }\n\n    // ------------------------------------------\n    // And now we have to adjust to make sense when the wheel is rotated from the 0 degrees either\n    // positive or negative and it can be many times past 360 degrees.\n    if (this.rotationAngle != 0) {\n      var rotatedPosition = this.getRotationPosition();\n\n      // So we have this, now we need to alter the locationAngle as a result of this.\n      locationAngle = locationAngle - rotatedPosition;\n\n      // If negative then take the location away from 360.\n      if (locationAngle < 0) {\n        locationAngle = 360 - Math.abs(locationAngle);\n      }\n    }\n\n    // ------------------------------------------\n    // OK, so after all of that we have the angle of a line between the centerX and centerY of the wheel and\n    // the X and Y of the location on the canvas where the mouse was clicked. Now time to work out the segment\n    // this corresponds to. We can use the segment start and end angles for this.\n    var foundSegmentNumber = null;\n    for (var x = 1; x <= this.numSegments; x++) {\n      // Due to segments sharing start and end angles, if line is clicked will pick earlier segment.\n      if (locationAngle >= this.segments[x].startAngle && locationAngle <= this.segments[x].endAngle) {\n        // To ensure that a click anywhere on the canvas in the segment direction will not cause a\n        // segment to be matched, as well as the angles, we need to ensure the click was within the radius\n        // of the segment (or circle if no segment radius).\n\n        // If the hypotenuseSideLength (length of location from the center of the wheel) is with the radius\n        // then we can assign the segment to the found segment and break out the loop.\n\n        // Have to take in to account hollow wheels (doughnuts) so check is greater than innerRadius as\n        // well as less than or equal to the outerRadius of the wheel.\n        if (hypotenuseSideLength >= this.innerRadius && hypotenuseSideLength <= this.outerRadius) {\n          foundSegmentNumber = x;\n          break;\n        }\n      }\n    }\n\n    // Finally return the number.\n    return foundSegmentNumber;\n  }\n\n  // ====================================================================================================================\n  // Returns a reference to the segment that is at the location of the pointer on the wheel.\n  // ====================================================================================================================\n  getIndicatedSegment() {\n    // Call function below to work this out and return the prizeNumber.\n    var prizeNumber = this.getIndicatedSegmentNumber();\n\n    // Then simply return the segment in the segments array at that position.\n    return this.segments[prizeNumber];\n  }\n\n  // ====================================================================================================================\n  // Works out the segment currently pointed to by the pointer of the wheel. Normally called when the spinning has stopped\n  // to work out the prize the user has won. Returns the number of the segment in the segments array.\n  // ====================================================================================================================\n  getIndicatedSegmentNumber() {\n    var indicatedPrize = 0;\n    var rawAngle = this.getRotationPosition();\n\n    // Now we have the angle of the wheel, but we need to take in to account where the pointer is because\n    // will not always be at the 12 o'clock 0 degrees location.\n    var relativeAngle = Math.floor(this.pointerAngle - rawAngle);\n    if (relativeAngle < 0) {\n      relativeAngle = 360 - Math.abs(relativeAngle);\n    }\n\n    // Now we can work out the prize won by seeing what prize segment startAngle and endAngle the relativeAngle is between.\n    for (var x = 1; x < this.segments.length; x++) {\n      if (relativeAngle >= this.segments[x]['startAngle'] && relativeAngle <= this.segments[x]['endAngle']) {\n        indicatedPrize = x;\n        break;\n      }\n    }\n    return indicatedPrize;\n  }\n\n  // ====================================================================================================================\n  // Works out what Pin around the wheel is considered the current one which is the one which just passed the pointer.\n  // Used to work out if the pin has changed during the animation to tigger a sound.\n  // ====================================================================================================================\n  getCurrentPinNumber() {\n    var currentPin = 0;\n    if (this.pins) {\n      var rawAngle = this.getRotationPosition();\n\n      // Now we have the angle of the wheel, but we need to take in to account where the pointer is because\n      // will not always be at the 12 o'clock 0 degrees location.\n      var relativeAngle = Math.floor(this.pointerAngle - rawAngle);\n      if (relativeAngle < 0) {\n        relativeAngle = 360 - Math.abs(relativeAngle);\n      }\n\n      // Work out the angle of the pins as this is simply 360 / the number of pins as they space evenly around.\n      var pinSpacing = 360 / this.pins.number;\n      var totalPinAngle = 0;\n\n      // Now we can work out the pin by seeing what pins relativeAngle is between.\n      for (var x = 0; x < this.pins.number; x++) {\n        if (relativeAngle >= totalPinAngle && relativeAngle <= totalPinAngle + pinSpacing) {\n          currentPin = x;\n          break;\n        }\n        totalPinAngle += pinSpacing;\n      }\n\n      // Now if rotating clockwise we must add 1 to the current pin as we want the pin which has just passed\n      // the pointer to be returned as the current pin, not the start of the one we are between.\n      if (this.animation.direction == 'clockwise') {\n        currentPin++;\n        if (currentPin > this.pins.number) {\n          currentPin = 0;\n        }\n      }\n    }\n    return currentPin;\n  }\n\n  // ==================================================================================================================================================\n  // Returns the rotation angle of the wheel corrected to 0-360 (i.e. removes all the multiples of 360).\n  // ==================================================================================================================================================\n  getRotationPosition() {\n    var rawAngle = this.rotationAngle; // Get current rotation angle of wheel.\n\n    // If positive work out how many times past 360 this is and then take the floor of this off the rawAngle.\n    if (rawAngle >= 0) {\n      if (rawAngle > 360) {\n        // Get floor of the number of times past 360 degrees.\n        var timesPast360 = Math.floor(rawAngle / 360);\n\n        // Take all this extra off to get just the angle 0-360 degrees.\n        rawAngle = rawAngle - 360 * timesPast360;\n      }\n    } else {\n      // Is negative, need to take off the extra then convert in to 0-360 degree value\n      // so if, for example, was -90 then final value will be (360 - 90) = 270 degrees.\n      if (rawAngle < -360) {\n        var timesPast360 = Math.ceil(rawAngle / 360); // Ceil when negative.\n\n        rawAngle = rawAngle - 360 * timesPast360; // Is minus because dealing with negative.\n      }\n\n      rawAngle = 360 + rawAngle; // Make in the range 0-360. Is plus because raw is still negative.\n    }\n\n    return rawAngle;\n  }\n\n  // ==================================================================================================================================================\n  // This function starts the wheel's animation by using the properties of the animation object of of the wheel to begin the a greensock tween.\n  // ==================================================================================================================================================\n  startAnimation() {\n    if (this.animation) {\n      // Call function to compute the animation properties.\n      this.computeAnimation();\n\n      // Set this global variable to this object as an external function is required to call the draw() function on the wheel\n      // each loop of the animation as Greensock cannot call the draw function directly on this class.\n      winwheelToDrawDuringAnimation = this;\n\n      // Put together the properties of the greesock animation.\n      var properties = new Array(null);\n      properties[this.animation.propertyName] = this.animation.propertyValue; // Here we set the property to be animated and its value.\n      properties['yoyo'] = this.animation.yoyo; // Set others.\n      properties['repeat'] = this.animation.repeat;\n      properties['ease'] = this.animation.easing;\n      properties['onUpdate'] = winwheelAnimationLoop; // Call function to re-draw the canvas.\n      properties['onComplete'] = winwheelStopAnimation; // Call function to perform actions when animation has finished.\n\n      // Do the tween animation passing the properties from the animation object as an array of key => value pairs.\n      // Keep reference to the tween object in the wheel as that allows pausing, resuming, and stopping while the animation is still running.\n      this.tween = TweenMax.to(this, this.animation.duration, properties);\n    }\n  }\n\n  // ==================================================================================================================================================\n  // Use same function function which needs to be outside the class for the callback when it stops because is finished.\n  // ==================================================================================================================================================\n  stopAnimation(canCallback) {\n    // @TODO as part of multiwheel, need to work out how to stop the tween for a single wheel but allow others to continue.\n\n    // We can kill the animation using our tween object.\n    if (winwheelToDrawDuringAnimation) {\n      winwheelToDrawDuringAnimation.tween.kill();\n\n      // Call the callback function.\n      winwheelStopAnimation(canCallback);\n    }\n\n    // Ensure the winwheelToDrawDuringAnimation is set to this class.\n    winwheelToDrawDuringAnimation = this;\n  }\n\n  // ==================================================================================================================================================\n  // Pause animation by telling tween to pause.\n  // ==================================================================================================================================================\n  pauseAnimation() {\n    if (this.tween) {\n      this.tween.pause();\n    }\n  }\n\n  // ==================================================================================================================================================\n  // Resume the animation by telling tween to continue playing it.\n  // ==================================================================================================================================================\n  resumeAnimation() {\n    if (this.tween) {\n      this.tween.play();\n    }\n  }\n\n  // ====================================================================================================================\n  // Called at the beginning of the startAnimation function and computes the values needed to do the animation\n  // before it starts. This allows the developer to change the animation properties after the wheel has been created\n  // and have the animation use the new values of the animation properties.\n  // ====================================================================================================================\n  computeAnimation() {\n    if (this.animation) {\n      // Set the animation parameters for the specified animation type including some sensible defaults if values have not been specified.\n      if (this.animation.type == 'spinOngoing') {\n        // When spinning the rotationAngle is the wheel property which is animated.\n        this.animation.propertyName = 'rotationAngle';\n        if (this.animation.spins == null) {\n          this.animation.spins = 5;\n        }\n        if (this.animation.repeat == null) {\n          this.animation.repeat = -1; // -1 means it will repeat forever.\n        }\n\n        if (this.animation.easing == null) {\n          this.animation.easing = 'Linear.easeNone';\n        }\n        if (this.animation.yoyo == null) {\n          this.animation.yoyo = false;\n        }\n\n        // We need to calculate the propertyValue and this is the spins * 360 degrees.\n        this.animation.propertyValue = this.animation.spins * 360;\n\n        // If the direction is anti-clockwise then make the property value negative.\n        if (this.animation.direction == 'anti-clockwise') {\n          this.animation.propertyValue = 0 - this.animation.propertyValue;\n        }\n      } else if (this.animation.type == 'spinToStop') {\n        // Spin to stop the rotation angle is affected.\n        this.animation.propertyName = 'rotationAngle';\n        if (this.animation.spins == null) {\n          this.animation.spins = 5;\n        }\n        if (this.animation.repeat == null) {\n          this.animation.repeat = 0; // As this is spin to stop we don't normally want it repeated.\n        }\n\n        if (this.animation.easing == null) {\n          this.animation.easing = 'Power3.easeOut'; // This easing is fast start and slows over time.\n        }\n\n        if (this.animation.stopAngle == null) {\n          // If the stop angle has not been specified then pick random between 0 and 359.\n          this.animation._stopAngle = Math.floor(Math.random() * 359);\n        } else {\n          // We need to set the internal to 360 minus what the user entered because the wheel spins past 0 without\n          // this it would indicate the prize on the opposite side of the wheel. We aslo need to take in to account\n          // the pointerAngle as the stop angle needs to be relative to that.\n          this.animation._stopAngle = 360 - this.animation.stopAngle + this.pointerAngle;\n        }\n        if (this.animation.yoyo == null) {\n          this.animation.yoyo = false;\n        }\n\n        // The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\n        this.animation.propertyValue = this.animation.spins * 360;\n        if (this.animation.direction == 'anti-clockwise') {\n          this.animation.propertyValue = 0 - this.animation.propertyValue;\n\n          // Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\n          // place this is 360 minus the stop angle as the wheel is rotating backwards).\n          this.animation.propertyValue -= 360 - this.animation._stopAngle;\n        } else {\n          // Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\n          this.animation.propertyValue += this.animation._stopAngle;\n        }\n      } else if (this.animation.type == 'spinAndBack') {\n        // This is basically is a spin for a number of times then the animation reverses and goes back to start.\n        // If a repeat is specified then this can be used to make the wheel \"rock\" left and right.\n\n        // Again this is a spin so the rotationAngle the property which is animated.\n        this.animation.propertyName = 'rotationAngle';\n        if (this.animation.spins == null) {\n          this.animation.spins = 5;\n        }\n        if (this.animation.repeat == null) {\n          this.animation.repeat = 1; // This needs to be set to at least 1 in order for the animation to reverse.\n        }\n\n        if (this.animation.easing == null) {\n          this.animation.easing = 'Power2.easeInOut'; // This is slow at the start and end and fast in the middle.\n        }\n\n        if (this.animation.yoyo == null) {\n          this.animation.yoyo = true; // This needs to be set to true to have the animation reverse back like a yo-yo.\n        }\n\n        if (this.animation.stopAngle == null) {\n          this.animation._stopAngle = 0;\n        } else {\n          // We need to set the internal to 360 minus what the user entered\n          // because the wheel spins past 0 without this it would indicate the\n          // prize on the opposite side of the wheel.\n          this.animation._stopAngle = 360 - this.animation.stopAngle;\n        }\n\n        // The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\n        this.animation.propertyValue = this.animation.spins * 360;\n        if (this.animation.direction == 'anti-clockwise') {\n          this.animation.propertyValue = 0 - this.animation.propertyValue;\n\n          // Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\n          // place this is 360 minus the stop angle as the wheel is rotating backwards).\n          this.animation.propertyValue -= 360 - this.animation._stopAngle;\n        } else {\n          // Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\n          this.animation.propertyValue += this.animation._stopAngle;\n        }\n      } else if (this.animation.type == 'custom') {\n        // Do nothing as all values must be set by the developer in the parameters\n        // especially the propertyName and propertyValue.\n      }\n    }\n  }\n\n  // ====================================================================================================================\n  // Calculates and returns a random stop angle inside the specified segment number. Value will always be 1 degree inside\n  // the start and end of the segment to avoid issue with the segment overlap.\n  // ====================================================================================================================\n  getRandomForSegment(segmentNumber) {\n    var stopAngle = 0;\n    if (segmentNumber) {\n      if (typeof this.segments[segmentNumber] !== 'undefined') {\n        var startAngle = this.segments[segmentNumber].startAngle;\n        var endAngle = this.segments[segmentNumber].endAngle;\n        var range = endAngle - startAngle - 2;\n        if (range > 0) {\n          stopAngle = startAngle + 1 + Math.floor(Math.random() * range);\n        } else {\n          console.log('Segment size is too small to safely get random angle inside it');\n        }\n      } else {\n        console.log('Segment ' + segmentNumber + ' undefined');\n      }\n    } else {\n      console.log('Segment number not specified');\n    }\n    return stopAngle;\n  }\n}\n\n// ====================================================================================================================\n// Class for the wheel pins.\n// ====================================================================================================================\nexport class Pin {\n  constructor(options) {\n    var defaultOptions = {\n      visible: true,\n      // In future there might be some functionality related to the pins even if they are not displayed.\n      number: 36,\n      // The number of pins. These are evenly distributed around the wheel.\n      outerRadius: 3,\n      // Radius of the pins which determines their size.\n      fillStyle: 'grey',\n      // Fill colour of the pins.\n      strokeStyle: 'black',\n      // Line colour of the pins.\n      lineWidth: 1,\n      // Line width of the pins.\n      margin: 3 // The space between outside edge of the wheel and the pins.\n    };\n\n    // Now loop through the default options and create properties of this class set to the value for\n    // the option passed in if a value was, or if not then set the value of the default.\n    for (var key in defaultOptions) {\n      if (options != null && typeof options[key] !== 'undefined') this[key] = options[key];else this[key] = defaultOptions[key];\n    }\n\n    // Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n    if (options != null) {\n      for (var key in options) {\n        if (typeof this[key] === 'undefined') {\n          this[key] = options[key];\n        }\n      }\n    }\n  }\n}\n// ====================================================================================================================\n// Class for the wheel spinning animation which like a segment becomes a property of the wheel.\n// ====================================================================================================================\nexport class Animation {\n  constructor(options) {\n    // Most of these options are null because the defaults are different depending on the type of animation.\n    var defaultOptions = {\n      type: 'spinOngoing',\n      // For now there are only supported types are spinOngoing (continuous), spinToStop, spinAndBack, custom.\n      direction: 'clockwise',\n      // clockwise or anti-clockwise.\n      propertyName: null,\n      // The name of the winning wheel property to be affected by the animation.\n      propertyValue: null,\n      // The value the property is to be set to at the end of the animation.\n      duration: 10,\n      // Duration of the animation.\n      yoyo: false,\n      // If the animation is to reverse back again i.e. yo-yo.\n      repeat: null,\n      // The number of times the animation is to repeat, -1 will cause it to repeat forever.\n      easing: null,\n      // The easing to use for the animation, default is the best for spin to stop. Use Linear.easeNone for no easing.\n      stopAngle: null,\n      // Used for spinning, the angle at which the wheel is to stop.\n      spins: null,\n      // Used for spinning, the number of complete 360 degree rotations the wheel is to do.\n      clearTheCanvas: null,\n      // If set to true the canvas will be cleared before the wheel is re-drawn, false it will not, null the animation will abide by the value of this property for the parent wheel object.\n      callbackFinished: null,\n      // Function to callback when the animation has finished.\n      callbackBefore: null,\n      // Function to callback before the wheel is drawn each animation loop.\n      callbackAfter: null,\n      // Function to callback after the wheel is drawn each animation loop.\n      callbackSound: null,\n      // Function to callback if a sound should be triggered on change of segment or pin.\n      soundTrigger: 'segment' // Sound trigger type. Default is segment which triggers when segment changes, can be pin if to trigger when pin passes the pointer.\n    };\n\n    // Now loop through the default options and create properties of this class set to the value for\n    // the option passed in if a value was, or if not then set the value of the default.\n    for (var key in defaultOptions) {\n      if (options != null && typeof options[key] !== 'undefined') this[key] = options[key];else this[key] = defaultOptions[key];\n    }\n\n    // Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n    if (options != null) {\n      for (var key in options) {\n        if (typeof this[key] === 'undefined') {\n          this[key] = options[key];\n        }\n      }\n    }\n  }\n}\n// ====================================================================================================================\n// Class for segments. When creating a json of options can be passed in.\n// ====================================================================================================================\nexport class Segment {\n  constructor(options) {\n    // Define default options for segments, most are null so that the global defaults for the wheel\n    // are used if the values for a particular segment are not specifically set.\n    var defaultOptions = {\n      size: null,\n      // Leave null for automatic. Valid values are degrees 0-360. Use percentToDegrees function if needed to convert.\n      text: '',\n      // Default is blank.\n      fillStyle: null,\n      // If null for the rest the global default will be used.\n      strokeStyle: null,\n      lineWidth: null,\n      textFontFamily: null,\n      textFontSize: null,\n      textFontWeight: null,\n      textOrientation: null,\n      textAlignment: null,\n      textDirection: null,\n      textMargin: null,\n      textFillStyle: null,\n      textStrokeStyle: null,\n      textLineWidth: null,\n      image: null,\n      // Name/path to the image\n      imageDirection: null,\n      // Direction of the image, can be set globally for the whole wheel.\n      imgData: null // Image object created here and loaded with image data.\n    };\n\n    // Now loop through the default options and create properties of this class set to the value for\n    // the option passed in if a value was, or if not then set the value of the default.\n    for (var key in defaultOptions) {\n      if (options != null && typeof options[key] !== 'undefined') this[key] = options[key];else this[key] = defaultOptions[key];\n    }\n\n    // Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n    // This allows the developer to easily add properties to segments at construction time.\n    if (options != null) {\n      for (var key in options) {\n        if (typeof this[key] === 'undefined') {\n          this[key] = options[key];\n        }\n      }\n    }\n\n    // There are 2 additional properties which are set by the code, so need to define them here.\n    // They are not in the default options because they are not something that should be set by the user,\n    // the values are updated every time the updateSegmentSizes() function is called.\n    this.startAngle = 0;\n    this.endAngle = 0;\n  }\n\n  // ====================================================================================================================\n  // Changes an image for a segment by setting a callback to render the wheel once the image has loaded.\n  // ====================================================================================================================\n  changeImage(image, imageDirection) {\n    // Change image name, blank image data.\n    this.image = image;\n    this.imgData = null;\n\n    // Set direction.\n    if (imageDirection) {\n      this.imageDirection = imageDirection;\n    }\n\n    // Set imgData to a new image object, change set callback and change src (just like in wheel constructor).\n    winhweelAlreadyDrawn = false;\n    this.imgData = new Image();\n    this.imgData.onload = winwheelLoadedImage;\n    this.imgData.src = this.image;\n  }\n}\n\n// ====================================================================================================================\n// Class that is created as property of the wheel. Draws line from center of the wheel out to edge of canvas to\n// indicate where the code thinks the pointer location is. Helpful to get alignment correct esp when using images.\n// ====================================================================================================================\nexport class PointerGuide {\n  constructor(options) {\n    var defaultOptions = {\n      display: false,\n      strokeStyle: 'red',\n      lineWidth: 3\n    };\n\n    // Now loop through the default options and create properties of this class set to the value for\n    // the option passed in if a value was, or if not then set the value of the default.\n    for (var key in defaultOptions) {\n      if (options != null && typeof options[key] !== 'undefined') {\n        this[key] = options[key];\n      } else {\n        this[key] = defaultOptions[key];\n      }\n    }\n  }\n}\n\n// ====================================================================================================================\n// This function takes the percent 0-100 and returns the number of degrees 0-360 this equates to.\n// ====================================================================================================================\nfunction winwheelPercentToDegrees(percentValue) {\n  var degrees = 0;\n  if (percentValue > 0 && percentValue <= 100) {\n    var divider = percentValue / 100;\n    degrees = 360 * divider;\n  }\n  return degrees;\n}\n\n// ====================================================================================================================\n// In order for the wheel to be re-drawn during the spin animation the function greesock calls needs to be outside\n// of the class as for some reason it errors if try to call winwheel.draw() directly.\n// ====================================================================================================================\nfunction winwheelAnimationLoop() {\n  if (winwheelToDrawDuringAnimation) {\n    // Check if the clearTheCanvas is specified for this animation, if not or it is not false then clear the canvas.\n    if (winwheelToDrawDuringAnimation.animation.clearTheCanvas != false) {\n      winwheelToDrawDuringAnimation.ctx.clearRect(0, 0, winwheelToDrawDuringAnimation.canvas.width, winwheelToDrawDuringAnimation.canvas.height);\n    }\n    var callbackBefore = winwheelToDrawDuringAnimation.animation.callbackBefore;\n    var callbackAfter = winwheelToDrawDuringAnimation.animation.callbackAfter;\n\n    // If there is a callback function which is supposed to be called before the wheel is drawn then do that.\n    if (callbackBefore != null) {\n      // If the property is a function then call it, otherwise eval the proptery as javascript code.\n      if (typeof callbackBefore === 'function') {\n        callbackBefore();\n      } else {\n        eval(callbackBefore);\n      }\n    }\n\n    // Call code to draw the wheel, pass in false as we never want it to clear the canvas as that would wipe anything drawn in the callbackBefore.\n    winwheelToDrawDuringAnimation.draw(false);\n\n    // If there is a callback function which is supposed to be called after the wheel has been drawn then do that.\n    if (callbackAfter != null) {\n      // If the property is a function then call it, otherwise eval the proptery as javascript code.\n      if (typeof callbackAfter === 'function') {\n        callbackAfter();\n      } else {\n        eval(callbackAfter);\n      }\n    }\n\n    // If there is a sound callback then call a function which figures out if the sound should be triggered\n    // and if so then call the function specified by the developer.\n    if (winwheelToDrawDuringAnimation.animation.callbackSound) {\n      winwheelTriggerSound();\n    }\n  }\n}\n\n// ====================================================================================================================\n// This function figures out if the callbackSound function needs to be called by working out if the segment or pin\n// has changed since the last animation loop.\n// ====================================================================================================================\nfunction winwheelTriggerSound() {\n  // If this property does not exist then add it as a property of the winwheel.\n  if (winwheelToDrawDuringAnimation.hasOwnProperty('_lastSoundTriggerNumber') == false) {\n    winwheelToDrawDuringAnimation._lastSoundTriggerNumber = 0;\n  }\n  var callbackSound = winwheelToDrawDuringAnimation.animation.callbackSound;\n  var currentTriggerNumber = 0;\n\n  // Now figure out if the sound callback should be called depending on the sound trigger type.\n  if (winwheelToDrawDuringAnimation.animation.soundTrigger == 'pin') {\n    // So for the pin type we need to work out which pin we are between.\n    currentTriggerNumber = winwheelToDrawDuringAnimation.getCurrentPinNumber();\n  } else {\n    // Check on the change of segment by working out which segment we are in.\n    // We can utilise the existing getIndiatedSegmentNumber function.\n    currentTriggerNumber = winwheelToDrawDuringAnimation.getIndicatedSegmentNumber();\n  }\n\n  // If the current number is not the same as last time then call the sound callback.\n  if (currentTriggerNumber != winwheelToDrawDuringAnimation._lastSoundTriggerNumber) {\n    // If the property is a function then call it, otherwise eval the proptery as javascript code.\n    if (typeof callbackSound === 'function') {\n      callbackSound();\n    } else {\n      eval(callbackSound);\n    }\n\n    // Also update the last sound trigger with the current number.\n    winwheelToDrawDuringAnimation._lastSoundTriggerNumber = currentTriggerNumber;\n  }\n}\n\n// ====================================================================================================================\n// This function is called-back when the greensock animation has finished.\n// ====================================================================================================================\nvar winwheelToDrawDuringAnimation = null; // This global is set by the winwheel class to the wheel object to be re-drawn.\n\nfunction winwheelStopAnimation(canCallback) {\n  // When the animation is stopped if canCallback is not false then try to call the callback.\n  // false can be passed in to stop the after happening if the animation has been stopped before it ended normally.\n  if (canCallback != false) {\n    var callback = winwheelToDrawDuringAnimation.animation.callbackFinished;\n    if (callback != null) {\n      // If the callback is a function then call it, otherwise evaluate the property as javascript code.\n      if (typeof callback === 'function') {\n        // Pass back the indicated segment as 99% of the time you will want to know this to inform the user of their prize.\n        callback(winwheelToDrawDuringAnimation.getIndicatedSegment());\n      } else {\n        eval(callback);\n      }\n    }\n  }\n}\n\n// ====================================================================================================================\n// Called after the image has loaded for each segment. Once all the images are loaded it then calls the draw function\n// on the wheel to render it. Used in constructor and also when a segment image is changed.\n// ====================================================================================================================\nvar winhweelAlreadyDrawn = false;\nfunction winwheelLoadedImage() {\n  // Prevent multiple drawings of the wheel which ocurrs without this check due to timing of function calls.\n  if (winhweelAlreadyDrawn == false) {\n    // Set to 0.\n    var winwheelImageLoadCount = 0;\n\n    // Loop though all the segments of the wheel and check if image data loaded, if so increment counter.\n    for (var i = 1; i <= winwheelToDrawDuringAnimation.numSegments; i++) {\n      // Check the image data object is not null and also that the image has completed loading by checking\n      // that a property of it such as the height has some sort of true value.\n      if (winwheelToDrawDuringAnimation.segments[i].imgData != null && winwheelToDrawDuringAnimation.segments[i].imgData.height) {\n        winwheelImageLoadCount++;\n      }\n    }\n\n    // If number of images loaded matches the segments then all the images for the wheel are loaded.\n    if (winwheelImageLoadCount == winwheelToDrawDuringAnimation.numSegments) {\n      // Call draw function to render the wheel.\n      winhweelAlreadyDrawn = true;\n      winwheelToDrawDuringAnimation.draw();\n    }\n  }\n}","map":{"version":3,"names":["TweenMax","Winwheel","constructor","options","drawWheel","defaultOptions","canvasId","centerX","centerY","outerRadius","innerRadius","numSegments","drawMode","rotationAngle","textFontFamily","textFontSize","textFontWeight","textOrientation","textAlignment","textDirection","textMargin","textFillStyle","textStrokeStyle","textLineWidth","fillStyle","strokeStyle","lineWidth","clearTheCanvas","imageOverlay","drawText","pointerAngle","wheelImage","imageDirection","key","canvas","document","getElementById","width","height","ctx","getContext","cavnas","segments","Array","x","Segment","updateSegmentSizes","animation","Animation","pins","Pin","pointerGuide","PointerGuide","draw","winwheelToDrawDuringAnimation","winhweelAlreadyDrawn","y","image","imgData","Image","onload","winwheelLoadedImage","src","arcUsed","numSet","size","arcLeft","degreesEach","currentDegree","startAngle","endAngle","clearCanvas","clearRect","drawWheelImage","drawSegmentText","drawSegments","drawSegmentImages","visible","drawPins","display","drawPointerGuide","number","pinSpacing","i","save","translate","rotate","degToRad","beginPath","arc","margin","Math","PI","fill","stroke","restore","moveTo","lineTo","imageLeft","imageTop","drawImage","seg","imageAngle","console","log","fontFamily","fontSize","fontWeight","orientation","alignment","direction","fontSetting","text","font","lines","split","lineOffset","length","textAlign","textBaseline","textAngle","fillText","strokeText","yPos","yInc","c","character","charAt","centerAdjustment","radius","anglePerChar","drawAngle","radiusPercent","totalArc","d","setCenter","addSegment","position","newSegment","segmentPos","setCanvasId","deleteSegment","undefined","windowToCanvas","bbox","getBoundingClientRect","floor","left","top","getSegmentAt","foundSegment","segmentNumber","getSegmentNumberAt","loc","topBottom","leftRight","adjacentSideLength","oppositeSideLength","hypotenuseSideLength","tanVal","result","atan","locationAngle","sqrt","round","rotatedPosition","getRotationPosition","abs","foundSegmentNumber","getIndicatedSegment","prizeNumber","getIndicatedSegmentNumber","indicatedPrize","rawAngle","relativeAngle","getCurrentPinNumber","currentPin","totalPinAngle","timesPast360","ceil","startAnimation","computeAnimation","properties","propertyName","propertyValue","yoyo","repeat","easing","winwheelAnimationLoop","winwheelStopAnimation","tween","to","duration","stopAnimation","canCallback","kill","pauseAnimation","pause","resumeAnimation","play","type","spins","stopAngle","_stopAngle","random","getRandomForSegment","range","callbackFinished","callbackBefore","callbackAfter","callbackSound","soundTrigger","changeImage","winwheelPercentToDegrees","percentValue","degrees","divider","eval","winwheelTriggerSound","hasOwnProperty","_lastSoundTriggerNumber","currentTriggerNumber","callback","winwheelImageLoadCount"],"sources":["C:/Users/Temporal/Desktop/Practicas/ruleta-test/node_modules/vue-winwheel/Winwheel.js"],"sourcesContent":["import { TweenMax } from 'gsap'\n\nexport class Winwheel {\n\tconstructor(options, drawWheel) {\n\t\tvar defaultOptions = {\n\t\t\tcanvasId: 'canvas', // Id of the canvas which the wheel is to draw on to.\n\t\t\tcenterX: null, // X position of the center of the wheel. The default of these are null which means will be placed in center of the canvas.\n\t\t\tcenterY: null, // Y position of the wheel center. If left null at time of construct the center of the canvas is used.\n\t\t\touterRadius: null, // The radius of the outside of the wheel. If left null it will be set to the radius from the center of the canvas to its shortest side.\n\t\t\tinnerRadius: 0, // Normally 0. Allows the creation of rings / doughnuts if set to value > 0. Should not exceed outer radius.\n\t\t\tnumSegments: 1, // The number of segments. Need at least one to draw.\n\t\t\tdrawMode: 'code', // The draw mode. Possible values are 'code', 'image', 'segmentImage'. Default is code which means segments are drawn using canvas arc() function.\n\t\t\trotationAngle: 0, // The angle of rotation of the wheel - 0 is 12 o'clock position.\n\t\t\ttextFontFamily: 'sans-serif', // Segment text font, you should use web safe fonts.\n\t\t\ttextFontSize: 13, // Size of the segment text.\n\t\t\ttextFontWeight: 'bold', // Font weight.\n\t\t\ttextOrientation: 'horizontal', // Either horizontal, vertical, or curved.\n\t\t\ttextAlignment: 'center', // Either center, inner, or outer.\n\t\t\ttextDirection: 'normal', // Either normal or reversed. In normal mode for horizontal text in segment at 3 o'clock is correct way up, in reversed text at 9 o'clock segment is correct way up.\n\t\t\ttextMargin: null, // Margin between the inner or outer of the wheel (depends on textAlignment).\n\t\t\ttextFillStyle: 'black', // This is basically the text colour.\n\t\t\ttextStrokeStyle: null, // Basically the line colour for segment text, only looks good for large text so off by default.\n\t\t\ttextLineWidth: 1, // Width of the lines around the text. Even though this defaults to 1, a line is only drawn if textStrokeStyle specified.\n\t\t\tfillStyle: 'silver', // The segment background colour.\n\t\t\tstrokeStyle: null, // Segment line colour. Again segment lines only drawn if this is specified.\n\t\t\tlineWidth: 1, // Width of lines around segments.\n\t\t\tclearTheCanvas: true, // When set to true the canvas will be cleared before the wheel is drawn.\n\t\t\timageOverlay: false, // If set to true in image drawing mode the outline of the segments will be displayed over the image. Does nothing in code drawMode.\n\t\t\tdrawText: true, // By default the text of the segments is rendered in code drawMode and not in image drawMode.\n\t\t\tpointerAngle: 0, // Location of the pointer that indicates the prize when wheel has stopped. Default is 0 so the (corrected) 12 o'clock position.\n\t\t\twheelImage: null, // Must be set to image data in order to use image to draw the wheel - drawMode must also be 'image'.\n\t\t\timageDirection: 'N', // Used when drawMode is segmentImage. Default is north, can also be (E)ast, (S)outh, (W)est.\n\t\t}\n\n\t\t// -----------------------------------------\n\t\t// Loop through the default options and create properties of this class set to the value for the option passed in\n\t\t// or if not value for the option was passed in then to the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') {\n\t\t\t\tthis[key] = options[key]\n\t\t\t} else {\n\t\t\t\tthis[key] = defaultOptions[key]\n\t\t\t}\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If the id of the canvas is set, try to get the canvas as we need it for drawing.\n\t\tif (this.canvasId) {\n\t\t\tthis.canvas = document.getElementById(this.canvasId)\n\n\t\t\tif (this.canvas) {\n\t\t\t\t// If the centerX and centerY have not been specified in the options then default to center of the canvas\n\t\t\t\t// and make the outerRadius half of the canvas width - this means the wheel will fill the canvas.\n\t\t\t\tif (this.centerX == null) {\n\t\t\t\t\tthis.centerX = this.canvas.width / 2\n\t\t\t\t}\n\n\t\t\t\tif (this.centerY == null) {\n\t\t\t\t\tthis.centerY = this.canvas.height / 2\n\t\t\t\t}\n\n\t\t\t\tif (this.outerRadius == null) {\n\t\t\t\t\t// Need to set to half the width of the shortest dimension of the canvas as the canvas may not be square.\n\t\t\t\t\t// Minus the line segment line width otherwise the lines around the segments on the top,left,bottom,right\n\t\t\t\t\t// side are chopped by the edge of the canvas.\n\t\t\t\t\tif (this.canvas.width < this.canvas.height) {\n\t\t\t\t\t\tthis.outerRadius = this.canvas.width / 2 - this.lineWidth\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.outerRadius = this.canvas.height / 2 - this.lineWidth\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Also get a 2D context to the canvas as we need this to draw with.\n\t\t\t\tthis.ctx = this.canvas.getContext('2d')\n\t\t\t} else {\n\t\t\t\tthis.canvas = null\n\t\t\t\tthis.ctx = null\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cavnas = null\n\t\t\tthis.ctx = null\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// Add array of segments to the wheel, then populate with segments if number of segments is specified for this object.\n\t\tthis.segments = new Array(null)\n\n\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t// If options for the segments have been specified then create a segment sending these options so\n\t\t\t// the specified values are used instead of the defaults.\n\t\t\tif (options != null && options['segments'] && typeof options['segments'][x - 1] !== 'undefined') {\n\t\t\t\tthis.segments[x] = new Segment(options['segments'][x - 1])\n\t\t\t} else {\n\t\t\t\tthis.segments[x] = new Segment()\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// Call function to update the segment sizes setting the starting and ending angles.\n\t\tthis.updateSegmentSizes()\n\n\t\t// If the text margin is null then set to same as font size as we want some by default.\n\t\tif (this.textMargin === null) {\n\t\t\tthis.textMargin = this.textFontSize / 1.7\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If the animation options have been passed in then create animation object as a property of this class\n\t\t// and pass the options to it so the animation is set. Otherwise create default animation object.\n\t\tif (options != null && options['animation'] && typeof options['animation'] !== 'undefined') {\n\t\t\tthis.animation = new Animation(options['animation'])\n\t\t} else {\n\t\t\tthis.animation = new Animation()\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If some pin options then create create a pin object and then pass them in.\n\t\tif (options != null && options['pins'] && typeof options['pins'] !== 'undefined') {\n\t\t\tthis.pins = new Pin(options['pins'])\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// On that note, if the drawMode is image change some defaults provided a value has not been specified.\n\t\tif (this.drawMode == 'image' || this.drawMode == 'segmentImage') {\n\t\t\t// Remove grey fillStyle.\n\t\t\tif (typeof options['fillStyle'] === 'undefined') {\n\t\t\t\tthis.fillStyle = null\n\t\t\t}\n\n\t\t\t// Set strokeStyle to red.\n\t\t\tif (typeof options['strokeStyle'] === 'undefined') {\n\t\t\t\tthis.strokeStyle = 'red'\n\t\t\t}\n\n\t\t\t// Set drawText to false as we will assume any text is part of the image.\n\t\t\tif (typeof options['drawText'] === 'undefined') {\n\t\t\t\tthis.drawText = false\n\t\t\t}\n\n\t\t\t// Also set the lineWidth to 1 so that segment overlay will look correct.\n\t\t\tif (typeof options['lineWidth'] === 'undefined') {\n\t\t\t\tthis.lineWidth = 1\n\t\t\t}\n\n\t\t\t// Set drawWheel to false as normally the image needs to be loaded first.\n\t\t\tif (typeof drawWheel === 'undefined') {\n\t\t\t\tdrawWheel = false\n\t\t\t}\n\t\t} else {\n\t\t\t// When in code drawMode the default is the wheel will draw.\n\t\t\tif (typeof drawWheel === 'undefined') {\n\t\t\t\tdrawWheel = true\n\t\t\t}\n\t\t}\n\n\t\t// Create pointer guide.\n\t\tif (options != null && options['pointerGuide'] && typeof options['pointerGuide'] !== 'undefined') {\n\t\t\tthis.pointerGuide = new PointerGuide(options['pointerGuide'])\n\t\t} else {\n\t\t\tthis.pointerGuide = new PointerGuide()\n\t\t}\n\n\t\t// Finally if drawWheel is true then call function to render the wheel, segment text, overlay etc.\n\t\tif (drawWheel == true) {\n\t\t\tthis.draw(this.clearTheCanvas)\n\t\t} else if (this.drawMode == 'segmentImage') {\n\t\t\t// If segment image then loop though all the segments and load the images for them setting a callback\n\t\t\t// which will call the draw function of the wheel once all the images have been loaded.\n\t\t\twinwheelToDrawDuringAnimation = this\n\t\t\twinhweelAlreadyDrawn = false\n\n\t\t\tfor (var y = 1; y <= this.numSegments; y++) {\n\t\t\t\tif (this.segments[y].image !== null) {\n\t\t\t\t\tthis.segments[y].imgData = new Image()\n\t\t\t\t\tthis.segments[y].imgData.onload = winwheelLoadedImage\n\t\t\t\t\tthis.segments[y].imgData.src = this.segments[y].image\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function sorts out the segment sizes. Some segments may have set sizes, for the others what is left out of\n\t// 360 degrees is shared evenly. What this function actually does is set the start and end angle of the arcs.\n\t// ====================================================================================================================\n\tupdateSegmentSizes() {\n\t\t// If this object actually contains some segments\n\t\tif (this.segments) {\n\t\t\t// First add up the arc used for the segments where the size has been set.\n\t\t\tvar arcUsed = 0\n\t\t\tvar numSet = 0\n\n\t\t\t// Remember, to make it easy to access segments, the position of the segments in the array starts from 1 (not 0).\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\tif (this.segments[x].size !== null) {\n\t\t\t\t\tarcUsed += this.segments[x].size\n\t\t\t\t\tnumSet++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar arcLeft = 360 - arcUsed\n\n\t\t\t// Create variable to hold how much each segment with non-set size will get in terms of degrees.\n\t\t\tvar degreesEach = 0\n\n\t\t\tif (arcLeft > 0) {\n\t\t\t\tdegreesEach = arcLeft / (this.numSegments - numSet)\n\t\t\t}\n\n\t\t\t// ------------------------------------------\n\t\t\t// Now loop though and set the start and end angle of each segment.\n\t\t\tvar currentDegree = 0\n\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t// Set start angle.\n\t\t\t\tthis.segments[x].startAngle = currentDegree\n\n\t\t\t\t// If the size is set then add this to the current degree to get the end, else add the degreesEach to it.\n\t\t\t\tif (this.segments[x].size) {\n\t\t\t\t\tcurrentDegree += this.segments[x].size\n\t\t\t\t} else {\n\t\t\t\t\tcurrentDegree += degreesEach\n\t\t\t\t}\n\n\t\t\t\t// Set end angle.\n\t\t\t\tthis.segments[x].endAngle = currentDegree\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function clears the canvas. Will wipe anything else which happens to be drawn on it.\n\t// ====================================================================================================================\n\tclearCanvas() {\n\t\tif (this.ctx) {\n\t\t\tthis.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws / re-draws the wheel on the canvas therefore rendering any changes.\n\t// ====================================================================================================================\n\tdraw(clearTheCanvas) {\n\t\t// If have the canvas context.\n\t\tif (this.ctx) {\n\t\t\t// Clear the canvas, unless told not to.\n\t\t\tif (typeof clearTheCanvas !== 'undefined') {\n\t\t\t\tif (clearTheCanvas == true) {\n\t\t\t\t\tthis.clearCanvas()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.clearCanvas()\n\t\t\t}\n\n\t\t\t// Call functions to draw the segments and then segment text.\n\t\t\tif (this.drawMode == 'image') {\n\t\t\t\t// Draw the wheel by loading and drawing an image such as a png on the canvas.\n\t\t\t\tthis.drawWheelImage()\n\n\t\t\t\t// If we are to draw the text, do so before the overlay is drawn\n\t\t\t\t// as this allows the overlay to be used to create some interesting effects.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\n\t\t\t\t// If image overlay is true then call function to draw the segments over the top of the image.\n\t\t\t\t// This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\n\t\t\t\tif (this.imageOverlay == true) {\n\t\t\t\t\tthis.drawSegments()\n\t\t\t\t}\n\t\t\t} else if (this.drawMode == 'segmentImage') {\n\t\t\t\t// Draw the wheel by rendering the image for each segment.\n\t\t\t\tthis.drawSegmentImages()\n\n\t\t\t\t// If we are to draw the text, do so before the overlay is drawn\n\t\t\t\t// as this allows the overlay to be used to create some interesting effects.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\n\t\t\t\t// If image overlay is true then call function to draw the segments over the top of the image.\n\t\t\t\t// This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\n\t\t\t\tif (this.imageOverlay == true) {\n\t\t\t\t\tthis.drawSegments()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// The default operation is to draw the segments using code via the canvas arc() method.\n\t\t\t\tthis.drawSegments()\n\n\t\t\t\t// The text is drawn on top.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this class has pins.\n\t\t\tif (typeof this.pins !== 'undefined') {\n\t\t\t\t// If they are to be visible then draw them.\n\t\t\t\tif (this.pins.visible == true) this.drawPins()\n\t\t\t}\n\n\t\t\t// If pointer guide is display property is set to true then call function to draw the pointer guide.\n\t\t\tif (this.pointerGuide.display == true) {\n\t\t\t\tthis.drawPointerGuide()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Draws the pins around the outside of the wheel.\n\t// ====================================================================================================================\n\tdrawPins() {\n\t\tif (this.pins && this.pins.number) {\n\t\t\t// Work out the angle to draw each pin a which is simply 360 / the number of pins as they space evenly around.\n\t\t\t//++ There is a slight oddity with the pins in that there is a pin at 0 and also one at 360 and these will be drawn\n\t\t\t//++ directly over the top of each other. Also pins are 0 indexed which could possibly cause some confusion\n\t\t\t//++ with the getCurrentPin function - for now this is just used for audio so probably not a problem.\n\t\t\tvar pinSpacing = 360 / this.pins.number\n\n\t\t\tfor (var i = 1; i <= this.pins.number; i++) {\n\t\t\t\tthis.ctx.save()\n\n\t\t\t\t// Set the stroke style and line width.\n\t\t\t\tthis.ctx.strokeStyle = this.pins.strokeStyle\n\t\t\t\tthis.ctx.lineWidth = this.pins.lineWidth\n\t\t\t\tthis.ctx.fillStyle = this.pins.fillStyle\n\n\t\t\t\t// Move to the center.\n\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\n\t\t\t\t// Rotate to to the pin location which is i * the pinSpacing.\n\t\t\t\tthis.ctx.rotate(this.degToRad(i * pinSpacing + this.rotationAngle))\n\n\t\t\t\t// Move back out.\n\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t// Create a path for the pin circle.\n\t\t\t\tthis.ctx.beginPath()\n\t\t\t\t// x, y, radius, startAngle, endAngle.\n\t\t\t\tthis.ctx.arc(\n\t\t\t\t\tthis.centerX,\n\t\t\t\t\tthis.centerY - this.outerRadius + this.pins.outerRadius + this.pins.margin,\n\t\t\t\t\tthis.pins.outerRadius,\n\t\t\t\t\t0,\n\t\t\t\t\t2 * Math.PI\n\t\t\t\t)\n\n\t\t\t\tif (this.pins.fillStyle) this.ctx.fill()\n\n\t\t\t\tif (this.pins.strokeStyle) this.ctx.stroke()\n\n\t\t\t\tthis.ctx.restore()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Draws a line from the center of the wheel to the outside at the angle where the code thinks the pointer is.\n\t// ====================================================================================================================\n\tdrawPointerGuide() {\n\t\t// If have canvas context.\n\t\tif (this.ctx) {\n\t\t\tthis.ctx.save()\n\n\t\t\t// Rotate the canvas to the line goes towards the location of the pointer.\n\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\tthis.ctx.rotate(this.degToRad(this.pointerAngle))\n\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t// Set line colour and width.\n\t\t\tthis.ctx.strokeStyle = this.pointerGuide.strokeStyle\n\t\t\tthis.ctx.lineWidth = this.pointerGuide.lineWidth\n\n\t\t\t// Draw from the center of the wheel outwards past the wheel outer radius.\n\t\t\tthis.ctx.beginPath()\n\t\t\tthis.ctx.moveTo(this.centerX, this.centerY)\n\t\t\tthis.ctx.lineTo(this.centerX, -(this.outerRadius / 4))\n\n\t\t\tthis.ctx.stroke()\n\t\t\tthis.ctx.restore()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function takes an image such as PNG and draws it on the canvas making its center at the centerX and center for the wheel.\n\t// ====================================================================================================================\n\tdrawWheelImage() {\n\t\t// Double check the wheelImage property of this class is not null. This does not actually detect that an image\n\t\t// source was set and actually loaded so might get error if this is not the case. This is why the initial call\n\t\t// to draw() should be done from a wheelImage.onload callback as detailed in example documentation.\n\t\tif (this.wheelImage != null) {\n\t\t\t// Work out the correct X and Y to draw the image at. We need to get the center point of the image\n\t\t\t// aligned over the center point of the wheel, we can't just place it at 0, 0.\n\t\t\tvar imageLeft = this.centerX - this.wheelImage.height / 2\n\t\t\tvar imageTop = this.centerY - this.wheelImage.width / 2\n\n\t\t\t// Rotate and then draw the wheel.\n\t\t\t// We must rotate by the rotationAngle before drawing to ensure that image wheels will spin.\n\t\t\tthis.ctx.save()\n\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\tthis.ctx.rotate(this.degToRad(this.rotationAngle))\n\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\tthis.ctx.drawImage(this.wheelImage, imageLeft, imageTop)\n\n\t\t\tthis.ctx.restore()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws the wheel on the canvas by rendering the image for each segment.\n\t// ====================================================================================================================\n\tdrawSegmentImages() {\n\t\t// Again check have context in case this function was called directly and not via draw function.\n\t\tif (this.ctx) {\n\t\t\t// Draw the segments if there is at least one in the segments array.\n\t\t\tif (this.segments) {\n\t\t\t\t// Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\n\t\t\t\t// this is to avoid confusion when talking about the first segment.\n\t\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t\t// Check image has loaded so a property such as height has a value.\n\t\t\t\t\tif (seg.imgData.height) {\n\t\t\t\t\t\t// Work out the correct X and Y to draw the image at which depends on the direction of the image.\n\t\t\t\t\t\t// Images can be created in 4 directions. North, South, East, West.\n\t\t\t\t\t\t// North: Outside at top, inside at bottom. Sits evenly over the 0 degrees angle.\n\t\t\t\t\t\t// South: Outside at bottom, inside at top. Sits evenly over the 180 degrees angle.\n\t\t\t\t\t\t// East: Outside at right, inside at left. Sits evenly over the 90 degrees angle.\n\t\t\t\t\t\t// West: Outside at left, inside at right. Sits evenly over the 270 degrees angle.\n\t\t\t\t\t\tvar imageLeft = 0\n\t\t\t\t\t\tvar imageTop = 0\n\t\t\t\t\t\tvar imageAngle = 0\n\t\t\t\t\t\tvar imageDirection = ''\n\n\t\t\t\t\t\tif (seg.imageDirection !== null) imageDirection = seg.imageDirection\n\t\t\t\t\t\telse imageDirection = this.imageDirection\n\n\t\t\t\t\t\tif (imageDirection == 'S') {\n\t\t\t\t\t\t\t// Left set so image sits half/half over the 180 degrees point.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width / 2\n\n\t\t\t\t\t\t\t// Top so image starts at the centerY.\n\t\t\t\t\t\t\timageTop = this.centerY\n\n\t\t\t\t\t\t\t// Angle to draw the image is its starting angle + half its size.\n\t\t\t\t\t\t\t// Here we add 180 to the angle to the segment is poistioned correctly.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 180 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} else if (imageDirection == 'E') {\n\t\t\t\t\t\t\t// Left set so image starts and the center point.\n\t\t\t\t\t\t\timageLeft = this.centerX\n\n\t\t\t\t\t\t\t// Top is so that it sits half/half over the 90 degree point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height / 2\n\n\t\t\t\t\t\t\t// Again get the angle in the center of the segment and add it to the rotation angle.\n\t\t\t\t\t\t\t// this time we need to add 270 to that to the segment is rendered the correct place.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 270 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} else if (imageDirection == 'W') {\n\t\t\t\t\t\t\t// Left is the centerX minus the width of the image.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width\n\n\t\t\t\t\t\t\t// Top is so that it sits half/half over the 270 degree point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height / 2\n\n\t\t\t\t\t\t\t// Again get the angle in the center of the segment and add it to the rotation angle.\n\t\t\t\t\t\t\t// this time we need to add 90 to that to the segment is rendered the correct place.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 90 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} // North is the default.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Left set so image sits half/half over the 0 degrees point.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width / 2\n\n\t\t\t\t\t\t\t// Top so image is its height out (above) the center point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height\n\n\t\t\t\t\t\t\t// Angle to draw the image is its starting angle + half its size.\n\t\t\t\t\t\t\t// this sits it half/half over the center angle of the segment.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// --------------------------------------------------\n\t\t\t\t\t\t// Rotate to the position of the segment and then draw the image.\n\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\n\t\t\t\t\t\t// So math here is the rotation angle of the wheel plus half way between the start and end angle of the segment.\n\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(this.rotationAngle + imageAngle))\n\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t// Draw the image.\n\t\t\t\t\t\tthis.ctx.drawImage(seg.imgData, imageLeft, imageTop)\n\n\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Segment ' + x + ' imgData is not loaded')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws the wheel on the page by rendering the segments on the canvas.\n\t// ====================================================================================================================\n\tdrawSegments() {\n\t\t// Again check have context in case this function was called directly and not via draw function.\n\t\tif (this.ctx) {\n\t\t\t// Draw the segments if there is at least one in the segments array.\n\t\t\tif (this.segments) {\n\t\t\t\t// Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\n\t\t\t\t// this is to avoid confusion when talking about the first segment.\n\t\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t\tvar fillStyle\n\t\t\t\t\tvar lineWidth\n\t\t\t\t\tvar strokeStyle\n\n\t\t\t\t\t// Set the variables that defined in the segment, or use the default options.\n\t\t\t\t\tif (seg.fillStyle !== null) fillStyle = seg.fillStyle\n\t\t\t\t\telse fillStyle = this.fillStyle\n\n\t\t\t\t\tthis.ctx.fillStyle = fillStyle\n\n\t\t\t\t\tif (seg.lineWidth !== null) lineWidth = seg.lineWidth\n\t\t\t\t\telse lineWidth = this.lineWidth\n\n\t\t\t\t\tthis.ctx.lineWidth = lineWidth\n\n\t\t\t\t\tif (seg.strokeStyle !== null) strokeStyle = seg.strokeStyle\n\t\t\t\t\telse strokeStyle = this.strokeStyle\n\n\t\t\t\t\tthis.ctx.strokeStyle = strokeStyle\n\n\t\t\t\t\t// Check there is a strokeStyle or fillStyle, if either the the segment is invisible so should not\n\t\t\t\t\t// try to draw it otherwise a path is began but not ended.\n\t\t\t\t\tif (strokeStyle || fillStyle) {\n\t\t\t\t\t\t// ----------------------------------\n\t\t\t\t\t\t// Begin a path as the segment consists of an arc and 2 lines.\n\t\t\t\t\t\tthis.ctx.beginPath()\n\n\t\t\t\t\t\t// If don't have an inner radius then move to the center of the wheel as we want a line out from the center\n\t\t\t\t\t\t// to the start of the arc for the outside of the wheel when we arc. Canvas will draw the connecting line for us.\n\t\t\t\t\t\tif (!this.innerRadius) {\n\t\t\t\t\t\t\tthis.ctx.moveTo(this.centerX, this.centerY)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//++ do need to draw the starting line in the correct x + y based on the start angle\n\t\t\t\t\t\t\t//++ otherwise as seen when the wheel does not use up 360 the starting segment is missing the stroked side,\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw the outer arc of the segment clockwise in direction -->\n\t\t\t\t\t\tthis.ctx.arc(\n\t\t\t\t\t\t\tthis.centerX,\n\t\t\t\t\t\t\tthis.centerY,\n\t\t\t\t\t\t\tthis.outerRadius,\n\t\t\t\t\t\t\tthis.degToRad(seg.startAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\tthis.degToRad(seg.endAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (this.innerRadius) {\n\t\t\t\t\t\t\t// Draw another arc, this time anticlockwise <-- at the innerRadius between the end angle and the start angle.\n\t\t\t\t\t\t\t// Canvas will draw a connecting line from the end of the outer arc to the beginning of the inner arc completing the shape.\n\n\t\t\t\t\t\t\t//++ Think the reason the lines are thinner for 2 of the segments is because the thing auto chops part of it\n\t\t\t\t\t\t\t//++ when doing the next one. Again think that actually drawing the lines will help.\n\n\t\t\t\t\t\t\tthis.ctx.arc(\n\t\t\t\t\t\t\t\tthis.centerX,\n\t\t\t\t\t\t\t\tthis.centerY,\n\t\t\t\t\t\t\t\tthis.innerRadius,\n\t\t\t\t\t\t\t\tthis.degToRad(seg.endAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\t\tthis.degToRad(seg.startAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If no inner radius then we draw a line back to the center of the wheel.\n\t\t\t\t\t\t\tthis.ctx.lineTo(this.centerX, this.centerY)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fill and stroke the segment. Only do either if a style was specified, if the style is null then\n\t\t\t\t\t\t// we assume the developer did not want that particular thing.\n\t\t\t\t\t\t// For example no stroke style so no lines to be drawn.\n\t\t\t\t\t\tif (fillStyle) this.ctx.fill()\n\n\t\t\t\t\t\tif (strokeStyle) this.ctx.stroke()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This draws the text on the segments using the specified text options.\n\t// ====================================================================================================================\n\tdrawSegmentText() {\n\t\t// Again only draw the text if have a canvas context.\n\t\tif (this.ctx) {\n\t\t\t// Declare variables to hold the values. These are populated either with the value for the specific segment,\n\t\t\t// or if not specified then the global default value.\n\t\t\tvar fontFamily\n\t\t\tvar fontSize\n\t\t\tvar fontWeight\n\t\t\tvar orientation\n\t\t\tvar alignment\n\t\t\tvar direction\n\t\t\tvar margin\n\t\t\tvar fillStyle\n\t\t\tvar strokeStyle\n\t\t\tvar lineWidth\n\t\t\tvar fontSetting\n\n\t\t\t// Loop though all the segments.\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t// Save the context so it is certain that each segment text option will not affect the other.\n\t\t\t\tthis.ctx.save()\n\n\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t// Check is text as no point trying to draw if there is no text to render.\n\t\t\t\tif (seg.text) {\n\t\t\t\t\t// Set values to those for the specific segment or use global default if null.\n\t\t\t\t\tif (seg.textFontFamily !== null) fontFamily = seg.textFontFamily\n\t\t\t\t\telse fontFamily = this.textFontFamily\n\t\t\t\t\tif (seg.textFontSize !== null) fontSize = seg.textFontSize\n\t\t\t\t\telse fontSize = this.textFontSize\n\t\t\t\t\tif (seg.textFontWeight !== null) fontWeight = seg.textFontWeight\n\t\t\t\t\telse fontWeight = this.textFontWeight\n\t\t\t\t\tif (seg.textOrientation !== null) orientation = seg.textOrientation\n\t\t\t\t\telse orientation = this.textOrientation\n\t\t\t\t\tif (seg.textAlignment !== null) alignment = seg.textAlignment\n\t\t\t\t\telse alignment = this.textAlignment\n\t\t\t\t\tif (seg.textDirection !== null) direction = seg.textDirection\n\t\t\t\t\telse direction = this.textDirection\n\t\t\t\t\tif (seg.textMargin !== null) margin = seg.textMargin\n\t\t\t\t\telse margin = this.textMargin\n\t\t\t\t\tif (seg.textFillStyle !== null) fillStyle = seg.textFillStyle\n\t\t\t\t\telse fillStyle = this.textFillStyle\n\t\t\t\t\tif (seg.textStrokeStyle !== null) strokeStyle = seg.textStrokeStyle\n\t\t\t\t\telse strokeStyle = this.textStrokeStyle\n\t\t\t\t\tif (seg.textLineWidth !== null) lineWidth = seg.textLineWidth\n\t\t\t\t\telse lineWidth = this.textLineWidth\n\n\t\t\t\t\t// ------------------------------\n\t\t\t\t\t// We need to put the font bits together in to one string.\n\t\t\t\t\tfontSetting = ''\n\n\t\t\t\t\tif (fontWeight != null) fontSetting += fontWeight + ' '\n\n\t\t\t\t\tif (fontSize != null) fontSetting += fontSize + 'px ' // Fonts on canvas are always a px value.\n\n\t\t\t\t\tif (fontFamily != null) fontSetting += fontFamily\n\n\t\t\t\t\t// Now set the canvas context to the decided values.\n\t\t\t\t\tthis.ctx.font = fontSetting\n\t\t\t\t\tthis.ctx.fillStyle = fillStyle\n\t\t\t\t\tthis.ctx.strokeStyle = strokeStyle\n\t\t\t\t\tthis.ctx.lineWidth = lineWidth\n\n\t\t\t\t\t// Split the text in to multiple lines on the \\n character.\n\t\t\t\t\tvar lines = seg.text.split('\\n')\n\n\t\t\t\t\t// Figure out the starting offset for the lines as when there are multiple lines need to center the text\n\t\t\t\t\t// vertically in the segment (when thinking of normal horozontal text).\n\t\t\t\t\tvar lineOffset = 0 - fontSize * (lines.length / 2) + fontSize / 2\n\n\t\t\t\t\t// The offset works great for horozontal and vertial text, also centered curved. But when the text is curved\n\t\t\t\t\t// and the alignment is outer then the multiline text should not have some text outside the wheel. Same if inner curved.\n\t\t\t\t\tif (orientation == 'curved' && (alignment == 'inner' || alignment == 'outer')) {\n\t\t\t\t\t\tlineOffset = 0\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\t\t\t// ---------------------------------\n\t\t\t\t\t\t// If direction is reversed then do things differently than if normal (which is the default - see further down)\n\t\t\t\t\t\tif (direction == 'reversed') {\n\t\t\t\t\t\t\t// When drawing reversed or 'upside down' we need to do some trickery on our part.\n\t\t\t\t\t\t\t// The canvas text rendering function still draws the text left to right and the correct way up,\n\t\t\t\t\t\t\t// so we need to overcome this with rotating the opposite side of the wheel the correct way up then pulling the text\n\t\t\t\t\t\t\t// through the center point to the correct segment it is supposed to be on.\n\t\t\t\t\t\t\tif (orientation == 'horizontal') {\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textAlign = 'right'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textAlign = 'left'\n\t\t\t\t\t\t\t\telse this.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// Work out the angle to rotate the wheel, this is in the center of the segment but on the opposite side of the wheel which is why do -180.\n\t\t\t\t\t\t\t\tvar textAngle = this.degToRad(\n\t\t\t\t\t\t\t\t\tseg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90 - 180\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(textAngle)\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// In reversed state the margin is subtracted from the innerX.\n\t\t\t\t\t\t\t\t\t// When inner the inner radius also comes in to play.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.innerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.innerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// In reversed state the position is the center minus the radius + the margin for outer aligned text.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.outerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.outerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// In reversed state the everything in minused.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX -\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX -\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'vertical') {\n\t\t\t\t\t\t\t\t// See normal code further down for comments on how it works, this is similar by plus/minus is reversed.\n\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\t// In reversed mode this are reversed.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textBaseline = 'bottom'\n\t\t\t\t\t\t\t\telse this.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\tvar textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2 - 180\n\t\t\t\t\t\t\t\ttextAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(textAngle))\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\tif (alignment == 'outer') var yPos = this.centerY + this.outerRadius - margin\n\t\t\t\t\t\t\t\telse if (alignment == 'inner') var yPos = this.centerY + this.innerRadius + margin\n\n\t\t\t\t\t\t\t\t// I have found that the text looks best when a fraction of the font size is shaved off.\n\t\t\t\t\t\t\t\tvar yInc = fontSize - fontSize / 9\n\n\t\t\t\t\t\t\t\t// Loop though and output the characters.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// In reversed mode outer means text in 6 o'clock segment sits at bottom of the wheel and we draw up.\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// In reversed mode inner text is drawn from top of segment at 6 o'clock position to bottom of the wheel.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// Again for reversed this is the opposite of before.\n\t\t\t\t\t\t\t\t\t// If there is more than one character in the text then an adjustment to the position needs to be done.\n\t\t\t\t\t\t\t\t\t// What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tvar centerAdjustment = 0\n\n\t\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment = (yInc * (lines[i].length - 1)) / 2\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar yPos =\n\t\t\t\t\t\t\t\t\t\tthis.centerY +\n\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment +\n\t\t\t\t\t\t\t\t\t\tmargin\n\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'curved') {\n\t\t\t\t\t\t\t\t// There is no built in canvas function to draw text around an arc,\n\t\t\t\t\t\t\t\t// so we need to do this ourselves.\n\t\t\t\t\t\t\t\tvar radius = 0\n\n\t\t\t\t\t\t\t\t// Set the alignment of the text - inner, outer, or center by calculating\n\t\t\t\t\t\t\t\t// how far out from the center point of the wheel the text is drawn.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// When alignment is inner the radius is the innerRadius plus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer it is the outerRadius minus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.outerRadius - margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'bottom'\n\n\t\t\t\t\t\t\t\t\t// We need to adjust the radius in this case to take in to multiline text.\n\t\t\t\t\t\t\t\t\t// In this case the radius needs to be further out, not at the inner radius.\n\t\t\t\t\t\t\t\t\tradius -= fontSize * (lines.length - 1)\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// When center we want the text halfway between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the angle to increment by when looping though and outputting the characters in the text\n\t\t\t\t\t\t\t\t// as we do this by rotating the wheel small amounts adding each character.\n\t\t\t\t\t\t\t\tvar anglePerChar = 0\n\t\t\t\t\t\t\t\tvar drawAngle = 0\n\n\t\t\t\t\t\t\t\t// If more than one character in the text then...\n\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t// Text is drawn from the left.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'left'\n\n\t\t\t\t\t\t\t\t\t// Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\n\t\t\t\t\t\t\t\t\t// I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\n\t\t\t\t\t\t\t\t\t// using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\n\t\t\t\t\t\t\t\t\tanglePerChar = 4 * (fontSize / 10)\n\n\t\t\t\t\t\t\t\t\t// Work out what percentage the radius the text will be drawn at is of 100px.\n\t\t\t\t\t\t\t\t\tradiusPercent = 100 / radius\n\n\t\t\t\t\t\t\t\t\t// Then use this to scale up or down the anglePerChar value.\n\t\t\t\t\t\t\t\t\t// When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\n\t\t\t\t\t\t\t\t\t// away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\n\t\t\t\t\t\t\t\t\tanglePerChar = anglePerChar * radiusPercent\n\n\t\t\t\t\t\t\t\t\t// Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\n\t\t\t\t\t\t\t\t\t// To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\n\t\t\t\t\t\t\t\t\t// of the segment so that it sits centred.\n\t\t\t\t\t\t\t\t\ttotalArc = anglePerChar * lines[i].length\n\n\t\t\t\t\t\t\t\t\t// Now set initial draw angle to half way between the start and end of the segment.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// The initial draw angle is the center of the segment when only one character.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t\t// To ensure is dead-center the text alignment also needs to be centered.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\n\t\t\t\t\t\t\t\tdrawAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// And as with other 'reverse' text direction functions we need to subtract 180 degrees from the angle\n\t\t\t\t\t\t\t\t// because when it comes to draw the characters in the loop below we add the radius instead of subtract it.\n\t\t\t\t\t\t\t\tdrawAngle -= 180\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Now the drawing itself.\n\t\t\t\t\t\t\t\t// In reversed direction mode we loop through the characters in the text backwards in order for them to appear on screen correctly\n\t\t\t\t\t\t\t\tfor (c = lines[i].length; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\tthis.ctx.save()\n\n\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t// Rotate the wheel to the draw angle as we need to add the character at this location.\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(drawAngle))\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t\t// Now draw the character directly below the center point of the wheel at the appropriate radius.\n\t\t\t\t\t\t\t\t\t// Note in the reversed mode we add the radius to the this.centerY instead of subtract.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(character, this.centerX, this.centerY + radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(character, this.centerX, this.centerY + radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\t// Increment the drawAngle by the angle per character so next loop we rotate\n\t\t\t\t\t\t\t\t\t// to the next angle required to draw the character at.\n\t\t\t\t\t\t\t\t\tdrawAngle += anglePerChar\n\n\t\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Normal direction so do things normally.\n\t\t\t\t\t\t\t// Check text orientation, of horizontal then reasonably straight forward, if vertical then a bit more work to do.\n\t\t\t\t\t\t\tif (orientation == 'horizontal') {\n\t\t\t\t\t\t\t\t// Based on the text alignment, set the correct value in the context.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textAlign = 'left'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textAlign = 'right'\n\t\t\t\t\t\t\t\telse this.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\t// Set this too.\n\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// Work out the angle around the wheel to draw the text at, which is simply in the middle of the segment the text is for.\n\t\t\t\t\t\t\t\t// The rotation angle is added in to correct the annoyance with the canvas arc drawing functions which put the 0 degrees at the 3 oclock\n\t\t\t\t\t\t\t\tvar textAngle = this.degToRad(\n\t\t\t\t\t\t\t\t\tseg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t// We need to rotate in order to draw the text because it is output horizontally, so to\n\t\t\t\t\t\t\t\t// place correctly around the wheel for all but a segment at 3 o'clock we need to rotate.\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(textAngle)\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t// --------------------------\n\t\t\t\t\t\t\t\t// Draw the text based on its alignment adding margin if inner or outer.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// Inner means that the text is aligned with the inner of the wheel. If looking at a segment in in the 3 o'clock position\n\t\t\t\t\t\t\t\t\t// it would look like the text is left aligned within the segment.\n\n\t\t\t\t\t\t\t\t\t// Because the segments are smaller towards the inner of the wheel, in order for the text to fit is is a good idea that\n\t\t\t\t\t\t\t\t\t// a margin is added which pushes the text towards the outer a bit.\n\n\t\t\t\t\t\t\t\t\t// The inner radius also needs to be taken in to account as when inner aligned.\n\n\t\t\t\t\t\t\t\t\t// If fillstyle is set the draw the text filled in.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.innerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If stroke style is set draw the text outline.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.innerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer means the text is aligned with the outside of the wheel, so if looking at a segment in the 3 o'clock position\n\t\t\t\t\t\t\t\t\t// it would appear the text is right aligned. To position we add the radius of the wheel in to the equation\n\t\t\t\t\t\t\t\t\t// and subtract the margin this time, rather than add it.\n\n\t\t\t\t\t\t\t\t\t// I don't understand why, but in order of the text to render correctly with stroke and fill, the stroke needs to\n\t\t\t\t\t\t\t\t\t// come first when drawing outer, rather than second when doing inner.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.outerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If fillstyle the fill the text.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.outerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// In this case the text is to drawn centred in the segment.\n\t\t\t\t\t\t\t\t\t// Typically no margin is required, however even though centred the text can look closer to the inner of the wheel\n\t\t\t\t\t\t\t\t\t// due to the way the segments narrow in (is optical effect), so if a margin is specified it is placed on the inner\n\t\t\t\t\t\t\t\t\t// side so the text is pushed towards the outer.\n\n\t\t\t\t\t\t\t\t\t// If stoke style the stroke the text.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX +\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If fillstyle the fill the text.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX +\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Restore the context so that wheel is returned to original position.\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'vertical') {\n\t\t\t\t\t\t\t\t// If vertical then we need to do this ourselves because as far as I am aware there is no option built in to html canvas\n\t\t\t\t\t\t\t\t// which causes the text to draw downwards or upwards one character after another.\n\n\t\t\t\t\t\t\t\t// In this case the textAlign is always center, but the baseline is either top or bottom\n\t\t\t\t\t\t\t\t// depending on if inner or outer alignment has been specified.\n\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textBaseline = 'bottom'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\telse this.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// The angle to draw the text at is halfway between the end and the starting angle of the segment.\n\t\t\t\t\t\t\t\tvar textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t// Ensure the rotation angle of the wheel is added in, otherwise the test placement won't match\n\t\t\t\t\t\t\t\t// the segments they are supposed to be for.\n\t\t\t\t\t\t\t\ttextAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// Rotate so can begin to place the text.\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(textAngle))\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t// Work out the position to start drawing in based on the alignment.\n\t\t\t\t\t\t\t\t// If outer then when considering a segment at the 12 o'clock position want to start drawing down from the top of the wheel.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') var yPos = this.centerY - this.outerRadius + margin\n\t\t\t\t\t\t\t\telse if (alignment == 'inner') var yPos = this.centerY - this.innerRadius - margin\n\n\t\t\t\t\t\t\t\t// We need to know how much to move the y axis each time.\n\t\t\t\t\t\t\t\t// This is not quite simply the font size as that puts a larger gap in between the letters\n\t\t\t\t\t\t\t\t// than expected, especially with monospace fonts. I found that shaving a little off makes it look \"right\".\n\t\t\t\t\t\t\t\tvar yInc = fontSize - fontSize / 9\n\n\t\t\t\t\t\t\t\t// Loop though and output the characters.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// For this alignment we draw down from the top of a segment at the 12 o'clock position to simply\n\t\t\t\t\t\t\t\t\t// loop though the characters in order.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// Here we draw from the inner of the wheel up, but in order for the letters in the text text to\n\t\t\t\t\t\t\t\t\t// remain in the correct order when reading, we actually need to loop though the text characters backwards.\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// This is the most complex of the three as we need to draw the text top down centred between the inner and outer of the wheel.\n\t\t\t\t\t\t\t\t\t// So logically we have to put the middle character of the text in the center then put the others each side of it.\n\t\t\t\t\t\t\t\t\t// In reality that is a really bad way to do it, we can achieve the same if not better positioning using a\n\t\t\t\t\t\t\t\t\t// variation on the method used for the rendering of outer aligned text once we have figured out the height of the text.\n\n\t\t\t\t\t\t\t\t\t// If there is more than one character in the text then an adjustment to the position needs to be done.\n\t\t\t\t\t\t\t\t\t// What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tvar centerAdjustment = 0\n\n\t\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment = (yInc * (lines[i].length - 1)) / 2\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Now work out where to start rendering the string. This is half way between the inner and outer of the wheel, with the\n\t\t\t\t\t\t\t\t\t// centerAdjustment included to correctly position texts with more than one character over the center.\n\t\t\t\t\t\t\t\t\t// If there is a margin it is used to push the text away from the center of the wheel.\n\t\t\t\t\t\t\t\t\tvar yPos =\n\t\t\t\t\t\t\t\t\t\tthis.centerY -\n\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment -\n\t\t\t\t\t\t\t\t\t\tmargin\n\n\t\t\t\t\t\t\t\t\t// Now loop and draw just like outer text rendering.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'curved') {\n\t\t\t\t\t\t\t\t// There is no built in canvas function to draw text around an arc, so\n\t\t\t\t\t\t\t\t// we need to do this ourselves.\n\t\t\t\t\t\t\t\tvar radius = 0\n\n\t\t\t\t\t\t\t\t// Set the alignment of the text - inner, outer, or center by calculating\n\t\t\t\t\t\t\t\t// how far out from the center point of the wheel the text is drawn.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// When alignment is inner the radius is the innerRadius plus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'bottom'\n\n\t\t\t\t\t\t\t\t\t// We need to adjust the radius in this case to take in to multiline text.\n\t\t\t\t\t\t\t\t\t// In this case the radius needs to be further out, not at the inner radius.\n\t\t\t\t\t\t\t\t\tradius += fontSize * (lines.length - 1)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer it is the outerRadius minus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.outerRadius - margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// When center we want the text halfway between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the angle to increment by when looping though and outputting the characters in the text\n\t\t\t\t\t\t\t\t// as we do this by rotating the wheel small amounts adding each character.\n\t\t\t\t\t\t\t\tvar anglePerChar = 0\n\t\t\t\t\t\t\t\tvar drawAngle = 0\n\n\t\t\t\t\t\t\t\t// If more than one character in the text then...\n\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t// Text is drawn from the left.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'left'\n\n\t\t\t\t\t\t\t\t\t// Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\n\t\t\t\t\t\t\t\t\t// I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\n\t\t\t\t\t\t\t\t\t// using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\n\t\t\t\t\t\t\t\t\tanglePerChar = 4 * (fontSize / 10)\n\n\t\t\t\t\t\t\t\t\t// Work out what percentage the radius the text will be drawn at is of 100px.\n\t\t\t\t\t\t\t\t\tradiusPercent = 100 / radius\n\n\t\t\t\t\t\t\t\t\t// Then use this to scale up or down the anglePerChar value.\n\t\t\t\t\t\t\t\t\t// When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\n\t\t\t\t\t\t\t\t\t// away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\n\t\t\t\t\t\t\t\t\tanglePerChar = anglePerChar * radiusPercent\n\n\t\t\t\t\t\t\t\t\t// Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\n\t\t\t\t\t\t\t\t\t// To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\n\t\t\t\t\t\t\t\t\t// of the segment so that it sits centred.\n\t\t\t\t\t\t\t\t\ttotalArc = anglePerChar * lines[i].length\n\n\t\t\t\t\t\t\t\t\t// Now set initial draw angle to half way between the start and end of the segment.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// The initial draw angle is the center of the segment when only one character.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t\t// To ensure is dead-center the text alignment also needs to be centred.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\n\t\t\t\t\t\t\t\tdrawAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Now the drawing itself.\n\t\t\t\t\t\t\t\t// Loop for each character in the text.\n\t\t\t\t\t\t\t\tfor (c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\tthis.ctx.save()\n\n\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t// Rotate the wheel to the draw angle as we need to add the character at this location.\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(drawAngle))\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t\t// Now draw the character directly above the center point of the wheel at the appropriate radius.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(character, this.centerX, this.centerY - radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(character, this.centerX, this.centerY - radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\t// Increment the drawAngle by the angle per character so next loop we rotate\n\t\t\t\t\t\t\t\t\t// to the next angle required to draw the character at.\n\t\t\t\t\t\t\t\t\tdrawAngle += anglePerChar\n\n\t\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Increment this ready for the next time.\n\t\t\t\t\t\tlineOffset += fontSize\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Restore so all text options are reset ready for the next text.\n\t\t\t\tthis.ctx.restore()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Converts degrees to radians which is what is used when specifying the angles on HTML5 canvas arcs.\n\t// ====================================================================================================================\n\tdegToRad(d) {\n\t\treturn d * 0.0174532925199432957\n\t}\n\n\t// ====================================================================================================================\n\t// This function sets the center location of the wheel, saves a function call to set x then y.\n\t// ====================================================================================================================\n\tsetCenter(x, y) {\n\t\tthis.centerX = x\n\t\tthis.centerY = y\n\t}\n\n\t// ====================================================================================================================\n\t// This function allows a segment to be added to the wheel. The position of the segment is optional,\n\t// if not specified the new segment will be added to the end of the wheel.\n\t// ====================================================================================================================\n\taddSegment(options, position) {\n\t\t// Create a new segment object passing the options in.\n\t\tnewSegment = new Segment(options)\n\n\t\t// Increment the numSegments property of the class since new segment being added.\n\t\tthis.numSegments++\n\t\tvar segmentPos\n\n\t\t// Work out where to place the segment, the default is simply as a new segment at the end of the wheel.\n\t\tif (typeof position !== 'undefined') {\n\t\t\t// Because we need to insert the segment at this position, not overwrite it, we need to move all segments after this\n\t\t\t// location along one in the segments array, before finally adding this new segment at the specified location.\n\t\t\tfor (var x = this.numSegments; x > position; x--) {\n\t\t\t\tthis.segments[x] = this.segments[x - 1]\n\t\t\t}\n\n\t\t\tthis.segments[position] = newSegment\n\t\t\tsegmentPos = position\n\t\t} else {\n\t\t\tthis.segments[this.numSegments] = newSegment\n\t\t\tsegmentPos = this.numSegments\n\t\t}\n\n\t\t// Since a segment has been added the segment sizes need to be re-computed so call function to do this.\n\t\tthis.updateSegmentSizes()\n\n\t\t// Return the segment object just created in the wheel (JavaScript will return it by reference), so that\n\t\t// further things can be done with it by the calling code if desired.\n\t\treturn this.segments[segmentPos]\n\t}\n\n\t// ====================================================================================================================\n\t// This function must be used if the canvasId is changed as we also need to get the context of the new canvas.\n\t// ====================================================================================================================\n\tsetCanvasId(canvasId) {\n\t\tif (canvasId) {\n\t\t\tthis.canvasId = canvasId\n\t\t\tthis.canvas = document.getElementById(this.canvasId)\n\n\t\t\tif (this.canvas) {\n\t\t\t\tthis.ctx = this.canvas.getContext('2d')\n\t\t\t}\n\t\t} else {\n\t\t\tthis.canvasId = null\n\t\t\tthis.ctx = null\n\t\t\tthis.canvas = null\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function deletes the specified segment from the wheel by removing it from the segments array.\n\t// It then sorts out the other bits such as update of the numSegments.\n\t// ====================================================================================================================\n\tdeleteSegment(position) {\n\t\t// There needs to be at least one segment in order for the wheel to draw, so only allow delete if there\n\t\t// is more than one segment currently left in the wheel.\n\n\t\t//++ check that specifying a position that does not exist - say 10 in a 6 segment wheel does not cause issues.\n\t\tif (this.numSegments > 1) {\n\t\t\t// If the position of the segment to remove has been specified.\n\t\t\tif (typeof position !== 'undefined') {\n\t\t\t\t// The array is to be shortened so we need to move all segments after the one\n\t\t\t\t// to be removed down one so there is no gap.\n\t\t\t\tfor (var x = position; x < this.numSegments; x++) {\n\t\t\t\t\tthis.segments[x] = this.segments[x + 1]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unset the last item in the segments array since there is now one less.\n\t\t\tthis.segments[this.numSegments] = undefined\n\n\t\t\t// Decrement the number of segments,\n\t\t\t// then call function to update the segment sizes.\n\t\t\tthis.numSegments--\n\t\t\tthis.updateSegmentSizes()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function takes the x an the y of a mouse event, such as click or move, and converts the x and the y in to\n\t// co-ordinates on the canvas as the raw values are the x and the y from the top and left of the user's browser.\n\t// ====================================================================================================================\n\twindowToCanvas(x, y) {\n\t\tvar bbox = this.canvas.getBoundingClientRect()\n\n\t\treturn {\n\t\t\tx: Math.floor(x - bbox.left * (this.canvas.width / bbox.width)),\n\t\t\ty: Math.floor(y - bbox.top * (this.canvas.height / bbox.height)),\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function returns the segment object located at the specified x and y coordinates on the canvas.\n\t// It is used to allow things to be done with a segment clicked by the user, such as highlight, display or change some values, etc.\n\t// ====================================================================================================================\n\tgetSegmentAt(x, y) {\n\t\tvar foundSegment = null\n\n\t\t// Call function to return segment number.\n\t\tvar segmentNumber = this.getSegmentNumberAt(x, y)\n\n\t\t// If found one then set found segment to pointer to the segment object.\n\t\tif (segmentNumber !== null) {\n\t\t\tfoundSegment = this.segments[segmentNumber]\n\t\t}\n\n\t\treturn foundSegment\n\t}\n\n\t// ====================================================================================================================\n\t// Returns the number of the segment clicked instead of the segment object.\n\t// ====================================================================================================================\n\tgetSegmentNumberAt(x, y) {\n\t\t// KNOWN ISSUE: this does not work correct if the canvas is scaled using css, or has padding, border.\n\t\t// @TODO see if can find a solution at some point, check windowToCanvas working as needed, then below.\n\n\t\t// Call function above to convert the raw x and y from the user's browser to canvas coordinates\n\t\t// i.e. top and left is top and left of canvas, not top and left of the user's browser.\n\t\tvar loc = this.windowToCanvas(x, y)\n\n\t\t// ------------------------------------------\n\t\t// Now start the process of working out the segment clicked.\n\t\t// First we need to figure out the angle of an imaginary line between the centerX and centerY of the wheel and\n\t\t// the X and Y of the location (for example a mouse click).\n\t\tvar topBottom\n\t\tvar leftRight\n\t\tvar adjacentSideLength\n\t\tvar oppositeSideLength\n\t\tvar hypotenuseSideLength\n\n\t\t// We will use right triangle maths with the TAN function.\n\t\t// The start of the triangle is the wheel center, the adjacent side is along the x axis, and the opposite side is along the y axis.\n\n\t\t// We only ever use positive numbers to work out the triangle and the center of the wheel needs to be considered as 0 for the numbers\n\t\t// in the maths which is why there is the subtractions below. We also remember what quadrant of the wheel the location is in as we\n\t\t// need this information later to add 90, 180, 270 degrees to the angle worked out from the triangle to get the position around a 360 degree wheel.\n\t\tif (loc.x > this.centerX) {\n\t\t\tadjacentSideLength = loc.x - this.centerX\n\t\t\tleftRight = 'R' // Location is in the right half of the wheel.\n\t\t} else {\n\t\t\tadjacentSideLength = this.centerX - loc.x\n\t\t\tleftRight = 'L' // Location is in the left half of the wheel.\n\t\t}\n\n\t\tif (loc.y > this.centerY) {\n\t\t\toppositeSideLength = loc.y - this.centerY\n\t\t\ttopBottom = 'B' // Bottom half of wheel.\n\t\t} else {\n\t\t\toppositeSideLength = this.centerY - loc.y\n\t\t\ttopBottom = 'T' // Top Half of wheel.\n\t\t}\n\n\t\t// Now divide opposite by adjacent to get tan value.\n\t\tvar tanVal = oppositeSideLength / adjacentSideLength\n\n\t\t// Use the tan function and convert results to degrees since that is what we work with.\n\t\tvar result = (Math.atan(tanVal) * 180) / Math.PI\n\t\tvar locationAngle = 0\n\n\t\t// We also need the length of the hypotenuse as later on we need to compare this to the outerRadius of the segment / circle.\n\t\thypotenuseSideLength = Math.sqrt(\n\t\t\toppositeSideLength * oppositeSideLength + adjacentSideLength * adjacentSideLength\n\t\t)\n\n\t\t// ------------------------------------------\n\t\t// Now to make sense around the wheel we need to alter the values based on if the location was in top or bottom half\n\t\t// and also right or left half of the wheel, by adding 90, 180, 270 etc. Also for some the initial locationAngle needs to be inverted.\n\t\tif (topBottom == 'T' && leftRight == 'R') {\n\t\t\tlocationAngle = Math.round(90 - result)\n\t\t} else if (topBottom == 'B' && leftRight == 'R') {\n\t\t\tlocationAngle = Math.round(result + 90)\n\t\t} else if (topBottom == 'B' && leftRight == 'L') {\n\t\t\tlocationAngle = Math.round(90 - result + 180)\n\t\t} else if (topBottom == 'T' && leftRight == 'L') {\n\t\t\tlocationAngle = Math.round(result + 270)\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// And now we have to adjust to make sense when the wheel is rotated from the 0 degrees either\n\t\t// positive or negative and it can be many times past 360 degrees.\n\t\tif (this.rotationAngle != 0) {\n\t\t\tvar rotatedPosition = this.getRotationPosition()\n\n\t\t\t// So we have this, now we need to alter the locationAngle as a result of this.\n\t\t\tlocationAngle = locationAngle - rotatedPosition\n\n\t\t\t// If negative then take the location away from 360.\n\t\t\tif (locationAngle < 0) {\n\t\t\t\tlocationAngle = 360 - Math.abs(locationAngle)\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// OK, so after all of that we have the angle of a line between the centerX and centerY of the wheel and\n\t\t// the X and Y of the location on the canvas where the mouse was clicked. Now time to work out the segment\n\t\t// this corresponds to. We can use the segment start and end angles for this.\n\t\tvar foundSegmentNumber = null\n\n\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t// Due to segments sharing start and end angles, if line is clicked will pick earlier segment.\n\t\t\tif (locationAngle >= this.segments[x].startAngle && locationAngle <= this.segments[x].endAngle) {\n\t\t\t\t// To ensure that a click anywhere on the canvas in the segment direction will not cause a\n\t\t\t\t// segment to be matched, as well as the angles, we need to ensure the click was within the radius\n\t\t\t\t// of the segment (or circle if no segment radius).\n\n\t\t\t\t// If the hypotenuseSideLength (length of location from the center of the wheel) is with the radius\n\t\t\t\t// then we can assign the segment to the found segment and break out the loop.\n\n\t\t\t\t// Have to take in to account hollow wheels (doughnuts) so check is greater than innerRadius as\n\t\t\t\t// well as less than or equal to the outerRadius of the wheel.\n\t\t\t\tif (hypotenuseSideLength >= this.innerRadius && hypotenuseSideLength <= this.outerRadius) {\n\t\t\t\t\tfoundSegmentNumber = x\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finally return the number.\n\t\treturn foundSegmentNumber\n\t}\n\n\t// ====================================================================================================================\n\t// Returns a reference to the segment that is at the location of the pointer on the wheel.\n\t// ====================================================================================================================\n\tgetIndicatedSegment() {\n\t\t// Call function below to work this out and return the prizeNumber.\n\t\tvar prizeNumber = this.getIndicatedSegmentNumber()\n\n\t\t// Then simply return the segment in the segments array at that position.\n\t\treturn this.segments[prizeNumber]\n\t}\n\n\t// ====================================================================================================================\n\t// Works out the segment currently pointed to by the pointer of the wheel. Normally called when the spinning has stopped\n\t// to work out the prize the user has won. Returns the number of the segment in the segments array.\n\t// ====================================================================================================================\n\tgetIndicatedSegmentNumber() {\n\t\tvar indicatedPrize = 0\n\t\tvar rawAngle = this.getRotationPosition()\n\n\t\t// Now we have the angle of the wheel, but we need to take in to account where the pointer is because\n\t\t// will not always be at the 12 o'clock 0 degrees location.\n\t\tvar relativeAngle = Math.floor(this.pointerAngle - rawAngle)\n\n\t\tif (relativeAngle < 0) {\n\t\t\trelativeAngle = 360 - Math.abs(relativeAngle)\n\t\t}\n\n\t\t// Now we can work out the prize won by seeing what prize segment startAngle and endAngle the relativeAngle is between.\n\t\tfor (var x = 1; x < this.segments.length; x++) {\n\t\t\tif (relativeAngle >= this.segments[x]['startAngle'] && relativeAngle <= this.segments[x]['endAngle']) {\n\t\t\t\tindicatedPrize = x\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn indicatedPrize\n\t}\n\n\t// ====================================================================================================================\n\t// Works out what Pin around the wheel is considered the current one which is the one which just passed the pointer.\n\t// Used to work out if the pin has changed during the animation to tigger a sound.\n\t// ====================================================================================================================\n\tgetCurrentPinNumber() {\n\t\tvar currentPin = 0\n\n\t\tif (this.pins) {\n\t\t\tvar rawAngle = this.getRotationPosition()\n\n\t\t\t// Now we have the angle of the wheel, but we need to take in to account where the pointer is because\n\t\t\t// will not always be at the 12 o'clock 0 degrees location.\n\t\t\tvar relativeAngle = Math.floor(this.pointerAngle - rawAngle)\n\n\t\t\tif (relativeAngle < 0) {\n\t\t\t\trelativeAngle = 360 - Math.abs(relativeAngle)\n\t\t\t}\n\n\t\t\t// Work out the angle of the pins as this is simply 360 / the number of pins as they space evenly around.\n\t\t\tvar pinSpacing = 360 / this.pins.number\n\t\t\tvar totalPinAngle = 0\n\n\t\t\t// Now we can work out the pin by seeing what pins relativeAngle is between.\n\t\t\tfor (var x = 0; x < this.pins.number; x++) {\n\t\t\t\tif (relativeAngle >= totalPinAngle && relativeAngle <= totalPinAngle + pinSpacing) {\n\t\t\t\t\tcurrentPin = x\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\ttotalPinAngle += pinSpacing\n\t\t\t}\n\n\t\t\t// Now if rotating clockwise we must add 1 to the current pin as we want the pin which has just passed\n\t\t\t// the pointer to be returned as the current pin, not the start of the one we are between.\n\t\t\tif (this.animation.direction == 'clockwise') {\n\t\t\t\tcurrentPin++\n\n\t\t\t\tif (currentPin > this.pins.number) {\n\t\t\t\t\tcurrentPin = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn currentPin\n\t}\n\n\t// ==================================================================================================================================================\n\t// Returns the rotation angle of the wheel corrected to 0-360 (i.e. removes all the multiples of 360).\n\t// ==================================================================================================================================================\n\tgetRotationPosition() {\n\t\tvar rawAngle = this.rotationAngle // Get current rotation angle of wheel.\n\n\t\t// If positive work out how many times past 360 this is and then take the floor of this off the rawAngle.\n\t\tif (rawAngle >= 0) {\n\t\t\tif (rawAngle > 360) {\n\t\t\t\t// Get floor of the number of times past 360 degrees.\n\t\t\t\tvar timesPast360 = Math.floor(rawAngle / 360)\n\n\t\t\t\t// Take all this extra off to get just the angle 0-360 degrees.\n\t\t\t\trawAngle = rawAngle - 360 * timesPast360\n\t\t\t}\n\t\t} else {\n\t\t\t// Is negative, need to take off the extra then convert in to 0-360 degree value\n\t\t\t// so if, for example, was -90 then final value will be (360 - 90) = 270 degrees.\n\t\t\tif (rawAngle < -360) {\n\t\t\t\tvar timesPast360 = Math.ceil(rawAngle / 360) // Ceil when negative.\n\n\t\t\t\trawAngle = rawAngle - 360 * timesPast360 // Is minus because dealing with negative.\n\t\t\t}\n\n\t\t\trawAngle = 360 + rawAngle // Make in the range 0-360. Is plus because raw is still negative.\n\t\t}\n\n\t\treturn rawAngle\n\t}\n\n\t// ==================================================================================================================================================\n\t// This function starts the wheel's animation by using the properties of the animation object of of the wheel to begin the a greensock tween.\n\t// ==================================================================================================================================================\n\tstartAnimation() {\n\t\tif (this.animation) {\n\t\t\t// Call function to compute the animation properties.\n\t\t\tthis.computeAnimation()\n\n\t\t\t// Set this global variable to this object as an external function is required to call the draw() function on the wheel\n\t\t\t// each loop of the animation as Greensock cannot call the draw function directly on this class.\n\t\t\twinwheelToDrawDuringAnimation = this\n\n\t\t\t// Put together the properties of the greesock animation.\n\t\t\tvar properties = new Array(null)\n\t\t\tproperties[this.animation.propertyName] = this.animation.propertyValue // Here we set the property to be animated and its value.\n\t\t\tproperties['yoyo'] = this.animation.yoyo // Set others.\n\t\t\tproperties['repeat'] = this.animation.repeat\n\t\t\tproperties['ease'] = this.animation.easing\n\t\t\tproperties['onUpdate'] = winwheelAnimationLoop // Call function to re-draw the canvas.\n\t\t\tproperties['onComplete'] = winwheelStopAnimation // Call function to perform actions when animation has finished.\n\n\t\t\t// Do the tween animation passing the properties from the animation object as an array of key => value pairs.\n\t\t\t// Keep reference to the tween object in the wheel as that allows pausing, resuming, and stopping while the animation is still running.\n\t\t\tthis.tween = TweenMax.to(this, this.animation.duration, properties)\n\t\t}\n\t}\n\n\t// ==================================================================================================================================================\n\t// Use same function function which needs to be outside the class for the callback when it stops because is finished.\n\t// ==================================================================================================================================================\n\tstopAnimation(canCallback) {\n\t\t// @TODO as part of multiwheel, need to work out how to stop the tween for a single wheel but allow others to continue.\n\n\t\t// We can kill the animation using our tween object.\n\t\tif (winwheelToDrawDuringAnimation) {\n\t\t\twinwheelToDrawDuringAnimation.tween.kill()\n\n\t\t\t// Call the callback function.\n\t\t\twinwheelStopAnimation(canCallback)\n\t\t}\n\n\t\t// Ensure the winwheelToDrawDuringAnimation is set to this class.\n\t\twinwheelToDrawDuringAnimation = this\n\t}\n\n\t// ==================================================================================================================================================\n\t// Pause animation by telling tween to pause.\n\t// ==================================================================================================================================================\n\tpauseAnimation() {\n\t\tif (this.tween) {\n\t\t\tthis.tween.pause()\n\t\t}\n\t}\n\n\t// ==================================================================================================================================================\n\t// Resume the animation by telling tween to continue playing it.\n\t// ==================================================================================================================================================\n\tresumeAnimation() {\n\t\tif (this.tween) {\n\t\t\tthis.tween.play()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Called at the beginning of the startAnimation function and computes the values needed to do the animation\n\t// before it starts. This allows the developer to change the animation properties after the wheel has been created\n\t// and have the animation use the new values of the animation properties.\n\t// ====================================================================================================================\n\tcomputeAnimation() {\n\t\tif (this.animation) {\n\t\t\t// Set the animation parameters for the specified animation type including some sensible defaults if values have not been specified.\n\t\t\tif (this.animation.type == 'spinOngoing') {\n\t\t\t\t// When spinning the rotationAngle is the wheel property which is animated.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = -1 // -1 means it will repeat forever.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Linear.easeNone'\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = false\n\t\t\t\t}\n\n\t\t\t\t// We need to calculate the propertyValue and this is the spins * 360 degrees.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\t// If the direction is anti-clockwise then make the property value negative.\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'spinToStop') {\n\t\t\t\t// Spin to stop the rotation angle is affected.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = 0 // As this is spin to stop we don't normally want it repeated.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Power3.easeOut' // This easing is fast start and slows over time.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.stopAngle == null) {\n\t\t\t\t\t// If the stop angle has not been specified then pick random between 0 and 359.\n\t\t\t\t\tthis.animation._stopAngle = Math.floor(Math.random() * 359)\n\t\t\t\t} else {\n\t\t\t\t\t// We need to set the internal to 360 minus what the user entered because the wheel spins past 0 without\n\t\t\t\t\t// this it would indicate the prize on the opposite side of the wheel. We aslo need to take in to account\n\t\t\t\t\t// the pointerAngle as the stop angle needs to be relative to that.\n\t\t\t\t\tthis.animation._stopAngle = 360 - this.animation.stopAngle + this.pointerAngle\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = false\n\t\t\t\t}\n\n\t\t\t\t// The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\n\t\t\t\t\t// Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\n\t\t\t\t\t// place this is 360 minus the stop angle as the wheel is rotating backwards).\n\t\t\t\t\tthis.animation.propertyValue -= 360 - this.animation._stopAngle\n\t\t\t\t} else {\n\t\t\t\t\t// Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\n\t\t\t\t\tthis.animation.propertyValue += this.animation._stopAngle\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'spinAndBack') {\n\t\t\t\t// This is basically is a spin for a number of times then the animation reverses and goes back to start.\n\t\t\t\t// If a repeat is specified then this can be used to make the wheel \"rock\" left and right.\n\n\t\t\t\t// Again this is a spin so the rotationAngle the property which is animated.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = 1 // This needs to be set to at least 1 in order for the animation to reverse.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Power2.easeInOut' // This is slow at the start and end and fast in the middle.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = true // This needs to be set to true to have the animation reverse back like a yo-yo.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.stopAngle == null) {\n\t\t\t\t\tthis.animation._stopAngle = 0\n\t\t\t\t} else {\n\t\t\t\t\t// We need to set the internal to 360 minus what the user entered\n\t\t\t\t\t// because the wheel spins past 0 without this it would indicate the\n\t\t\t\t\t// prize on the opposite side of the wheel.\n\t\t\t\t\tthis.animation._stopAngle = 360 - this.animation.stopAngle\n\t\t\t\t}\n\n\t\t\t\t// The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\n\t\t\t\t\t// Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\n\t\t\t\t\t// place this is 360 minus the stop angle as the wheel is rotating backwards).\n\t\t\t\t\tthis.animation.propertyValue -= 360 - this.animation._stopAngle\n\t\t\t\t} else {\n\t\t\t\t\t// Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\n\t\t\t\t\tthis.animation.propertyValue += this.animation._stopAngle\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'custom') {\n\t\t\t\t// Do nothing as all values must be set by the developer in the parameters\n\t\t\t\t// especially the propertyName and propertyValue.\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Calculates and returns a random stop angle inside the specified segment number. Value will always be 1 degree inside\n\t// the start and end of the segment to avoid issue with the segment overlap.\n\t// ====================================================================================================================\n\tgetRandomForSegment(segmentNumber) {\n\t\tvar stopAngle = 0\n\n\t\tif (segmentNumber) {\n\t\t\tif (typeof this.segments[segmentNumber] !== 'undefined') {\n\t\t\t\tvar startAngle = this.segments[segmentNumber].startAngle\n\t\t\t\tvar endAngle = this.segments[segmentNumber].endAngle\n\t\t\t\tvar range = endAngle - startAngle - 2\n\n\t\t\t\tif (range > 0) {\n\t\t\t\t\tstopAngle = startAngle + 1 + Math.floor(Math.random() * range)\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('Segment size is too small to safely get random angle inside it')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log('Segment ' + segmentNumber + ' undefined')\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log('Segment number not specified')\n\t\t}\n\n\t\treturn stopAngle\n\t}\n}\n\n// ====================================================================================================================\n// Class for the wheel pins.\n// ====================================================================================================================\nexport class Pin {\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvisible: true, // In future there might be some functionality related to the pins even if they are not displayed.\n\t\t\tnumber: 36, // The number of pins. These are evenly distributed around the wheel.\n\t\t\touterRadius: 3, // Radius of the pins which determines their size.\n\t\t\tfillStyle: 'grey', // Fill colour of the pins.\n\t\t\tstrokeStyle: 'black', // Line colour of the pins.\n\t\t\tlineWidth: 1, // Line width of the pins.\n\t\t\tmargin: 3, // The space between outside edge of the wheel and the pins.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// ====================================================================================================================\n// Class for the wheel spinning animation which like a segment becomes a property of the wheel.\n// ====================================================================================================================\nexport class Animation {\n\tconstructor(options) {\n\t\t// Most of these options are null because the defaults are different depending on the type of animation.\n\t\tvar defaultOptions = {\n\t\t\ttype: 'spinOngoing', // For now there are only supported types are spinOngoing (continuous), spinToStop, spinAndBack, custom.\n\t\t\tdirection: 'clockwise', // clockwise or anti-clockwise.\n\t\t\tpropertyName: null, // The name of the winning wheel property to be affected by the animation.\n\t\t\tpropertyValue: null, // The value the property is to be set to at the end of the animation.\n\t\t\tduration: 10, // Duration of the animation.\n\t\t\tyoyo: false, // If the animation is to reverse back again i.e. yo-yo.\n\t\t\trepeat: null, // The number of times the animation is to repeat, -1 will cause it to repeat forever.\n\t\t\teasing: null, // The easing to use for the animation, default is the best for spin to stop. Use Linear.easeNone for no easing.\n\t\t\tstopAngle: null, // Used for spinning, the angle at which the wheel is to stop.\n\t\t\tspins: null, // Used for spinning, the number of complete 360 degree rotations the wheel is to do.\n\t\t\tclearTheCanvas: null, // If set to true the canvas will be cleared before the wheel is re-drawn, false it will not, null the animation will abide by the value of this property for the parent wheel object.\n\t\t\tcallbackFinished: null, // Function to callback when the animation has finished.\n\t\t\tcallbackBefore: null, // Function to callback before the wheel is drawn each animation loop.\n\t\t\tcallbackAfter: null, // Function to callback after the wheel is drawn each animation loop.\n\t\t\tcallbackSound: null, // Function to callback if a sound should be triggered on change of segment or pin.\n\t\t\tsoundTrigger: 'segment', // Sound trigger type. Default is segment which triggers when segment changes, can be pin if to trigger when pin passes the pointer.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// ====================================================================================================================\n// Class for segments. When creating a json of options can be passed in.\n// ====================================================================================================================\nexport class Segment {\n\tconstructor(options) {\n\t\t// Define default options for segments, most are null so that the global defaults for the wheel\n\t\t// are used if the values for a particular segment are not specifically set.\n\t\tvar defaultOptions = {\n\t\t\tsize: null, // Leave null for automatic. Valid values are degrees 0-360. Use percentToDegrees function if needed to convert.\n\t\t\ttext: '', // Default is blank.\n\t\t\tfillStyle: null, // If null for the rest the global default will be used.\n\t\t\tstrokeStyle: null,\n\t\t\tlineWidth: null,\n\t\t\ttextFontFamily: null,\n\t\t\ttextFontSize: null,\n\t\t\ttextFontWeight: null,\n\t\t\ttextOrientation: null,\n\t\t\ttextAlignment: null,\n\t\t\ttextDirection: null,\n\t\t\ttextMargin: null,\n\t\t\ttextFillStyle: null,\n\t\t\ttextStrokeStyle: null,\n\t\t\ttextLineWidth: null,\n\t\t\timage: null, // Name/path to the image\n\t\t\timageDirection: null, // Direction of the image, can be set globally for the whole wheel.\n\t\t\timgData: null, // Image object created here and loaded with image data.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\t// This allows the developer to easily add properties to segments at construction time.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// There are 2 additional properties which are set by the code, so need to define them here.\n\t\t// They are not in the default options because they are not something that should be set by the user,\n\t\t// the values are updated every time the updateSegmentSizes() function is called.\n\t\tthis.startAngle = 0\n\t\tthis.endAngle = 0\n\t}\n\n\t// ====================================================================================================================\n\t// Changes an image for a segment by setting a callback to render the wheel once the image has loaded.\n\t// ====================================================================================================================\n\tchangeImage(image, imageDirection) {\n\t\t// Change image name, blank image data.\n\t\tthis.image = image\n\t\tthis.imgData = null\n\n\t\t// Set direction.\n\t\tif (imageDirection) {\n\t\t\tthis.imageDirection = imageDirection\n\t\t}\n\n\t\t// Set imgData to a new image object, change set callback and change src (just like in wheel constructor).\n\t\twinhweelAlreadyDrawn = false\n\t\tthis.imgData = new Image()\n\t\tthis.imgData.onload = winwheelLoadedImage\n\t\tthis.imgData.src = this.image\n\t}\n}\n\n// ====================================================================================================================\n// Class that is created as property of the wheel. Draws line from center of the wheel out to edge of canvas to\n// indicate where the code thinks the pointer location is. Helpful to get alignment correct esp when using images.\n// ====================================================================================================================\nexport class PointerGuide {\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tdisplay: false,\n\t\t\tstrokeStyle: 'red',\n\t\t\tlineWidth: 3,\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') {\n\t\t\t\tthis[key] = options[key]\n\t\t\t} else {\n\t\t\t\tthis[key] = defaultOptions[key]\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// This function takes the percent 0-100 and returns the number of degrees 0-360 this equates to.\n// ====================================================================================================================\nfunction winwheelPercentToDegrees(percentValue) {\n\tvar degrees = 0\n\n\tif (percentValue > 0 && percentValue <= 100) {\n\t\tvar divider = percentValue / 100\n\t\tdegrees = 360 * divider\n\t}\n\n\treturn degrees\n}\n\n// ====================================================================================================================\n// In order for the wheel to be re-drawn during the spin animation the function greesock calls needs to be outside\n// of the class as for some reason it errors if try to call winwheel.draw() directly.\n// ====================================================================================================================\nfunction winwheelAnimationLoop() {\n\tif (winwheelToDrawDuringAnimation) {\n\t\t// Check if the clearTheCanvas is specified for this animation, if not or it is not false then clear the canvas.\n\t\tif (winwheelToDrawDuringAnimation.animation.clearTheCanvas != false) {\n\t\t\twinwheelToDrawDuringAnimation.ctx.clearRect(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\twinwheelToDrawDuringAnimation.canvas.width,\n\t\t\t\twinwheelToDrawDuringAnimation.canvas.height\n\t\t\t)\n\t\t}\n\n\t\tvar callbackBefore = winwheelToDrawDuringAnimation.animation.callbackBefore\n\t\tvar callbackAfter = winwheelToDrawDuringAnimation.animation.callbackAfter\n\n\t\t// If there is a callback function which is supposed to be called before the wheel is drawn then do that.\n\t\tif (callbackBefore != null) {\n\t\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\t\tif (typeof callbackBefore === 'function') {\n\t\t\t\tcallbackBefore()\n\t\t\t} else {\n\t\t\t\teval(callbackBefore)\n\t\t\t}\n\t\t}\n\n\t\t// Call code to draw the wheel, pass in false as we never want it to clear the canvas as that would wipe anything drawn in the callbackBefore.\n\t\twinwheelToDrawDuringAnimation.draw(false)\n\n\t\t// If there is a callback function which is supposed to be called after the wheel has been drawn then do that.\n\t\tif (callbackAfter != null) {\n\t\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\t\tif (typeof callbackAfter === 'function') {\n\t\t\t\tcallbackAfter()\n\t\t\t} else {\n\t\t\t\teval(callbackAfter)\n\t\t\t}\n\t\t}\n\n\t\t// If there is a sound callback then call a function which figures out if the sound should be triggered\n\t\t// and if so then call the function specified by the developer.\n\t\tif (winwheelToDrawDuringAnimation.animation.callbackSound) {\n\t\t\twinwheelTriggerSound()\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// This function figures out if the callbackSound function needs to be called by working out if the segment or pin\n// has changed since the last animation loop.\n// ====================================================================================================================\nfunction winwheelTriggerSound() {\n\t// If this property does not exist then add it as a property of the winwheel.\n\tif (winwheelToDrawDuringAnimation.hasOwnProperty('_lastSoundTriggerNumber') == false) {\n\t\twinwheelToDrawDuringAnimation._lastSoundTriggerNumber = 0\n\t}\n\n\tvar callbackSound = winwheelToDrawDuringAnimation.animation.callbackSound\n\tvar currentTriggerNumber = 0\n\n\t// Now figure out if the sound callback should be called depending on the sound trigger type.\n\tif (winwheelToDrawDuringAnimation.animation.soundTrigger == 'pin') {\n\t\t// So for the pin type we need to work out which pin we are between.\n\t\tcurrentTriggerNumber = winwheelToDrawDuringAnimation.getCurrentPinNumber()\n\t} else {\n\t\t// Check on the change of segment by working out which segment we are in.\n\t\t// We can utilise the existing getIndiatedSegmentNumber function.\n\t\tcurrentTriggerNumber = winwheelToDrawDuringAnimation.getIndicatedSegmentNumber()\n\t}\n\n\t// If the current number is not the same as last time then call the sound callback.\n\tif (currentTriggerNumber != winwheelToDrawDuringAnimation._lastSoundTriggerNumber) {\n\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\tif (typeof callbackSound === 'function') {\n\t\t\tcallbackSound()\n\t\t} else {\n\t\t\teval(callbackSound)\n\t\t}\n\n\t\t// Also update the last sound trigger with the current number.\n\t\twinwheelToDrawDuringAnimation._lastSoundTriggerNumber = currentTriggerNumber\n\t}\n}\n\n// ====================================================================================================================\n// This function is called-back when the greensock animation has finished.\n// ====================================================================================================================\nvar winwheelToDrawDuringAnimation = null // This global is set by the winwheel class to the wheel object to be re-drawn.\n\nfunction winwheelStopAnimation(canCallback) {\n\t// When the animation is stopped if canCallback is not false then try to call the callback.\n\t// false can be passed in to stop the after happening if the animation has been stopped before it ended normally.\n\tif (canCallback != false) {\n\t\tvar callback = winwheelToDrawDuringAnimation.animation.callbackFinished\n\n\t\tif (callback != null) {\n\t\t\t// If the callback is a function then call it, otherwise evaluate the property as javascript code.\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\t// Pass back the indicated segment as 99% of the time you will want to know this to inform the user of their prize.\n\t\t\t\tcallback(winwheelToDrawDuringAnimation.getIndicatedSegment())\n\t\t\t} else {\n\t\t\t\teval(callback)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// Called after the image has loaded for each segment. Once all the images are loaded it then calls the draw function\n// on the wheel to render it. Used in constructor and also when a segment image is changed.\n// ====================================================================================================================\nvar winhweelAlreadyDrawn = false\n\nfunction winwheelLoadedImage() {\n\t// Prevent multiple drawings of the wheel which ocurrs without this check due to timing of function calls.\n\tif (winhweelAlreadyDrawn == false) {\n\t\t// Set to 0.\n\t\tvar winwheelImageLoadCount = 0\n\n\t\t// Loop though all the segments of the wheel and check if image data loaded, if so increment counter.\n\t\tfor (var i = 1; i <= winwheelToDrawDuringAnimation.numSegments; i++) {\n\t\t\t// Check the image data object is not null and also that the image has completed loading by checking\n\t\t\t// that a property of it such as the height has some sort of true value.\n\t\t\tif (\n\t\t\t\twinwheelToDrawDuringAnimation.segments[i].imgData != null &&\n\t\t\t\twinwheelToDrawDuringAnimation.segments[i].imgData.height\n\t\t\t) {\n\t\t\t\twinwheelImageLoadCount++\n\t\t\t}\n\t\t}\n\n\t\t// If number of images loaded matches the segments then all the images for the wheel are loaded.\n\t\tif (winwheelImageLoadCount == winwheelToDrawDuringAnimation.numSegments) {\n\t\t\t// Call draw function to render the wheel.\n\t\t\twinhweelAlreadyDrawn = true\n\t\t\twinwheelToDrawDuringAnimation.draw()\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}